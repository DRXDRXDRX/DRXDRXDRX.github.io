<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>前端面试突破：JavaScript（2万字长文！！！） | 灰太羊的羊村</title><meta name="author" content="灰太羊"><meta name="copyright" content="灰太羊"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="本文围绕 JavaScript 的各类重点知识，通过对面试高频考题的归纳与讲解，让你了解面试考核重心，掌握问题背后的底层知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试突破：JavaScript（2万字长文！！！）">
<meta property="og:url" content="https://blog.huitaiyang.top/2024/09/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4%EF%BC%9AJavaScript(2%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87)/index.html">
<meta property="og:site_name" content="灰太羊的羊村">
<meta property="og:description" content="本文围绕 JavaScript 的各类重点知识，通过对面试高频考题的归纳与讲解，让你了解面试考核重心，掌握问题背后的底层知识。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202409191948011.png">
<meta property="article:published_time" content="2024-09-19T11:44:55.000Z">
<meta property="article:modified_time" content="2024-09-19T12:45:56.488Z">
<meta property="article:author" content="灰太羊">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202409191948011.png"><link rel="shortcut icon" href="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408141643894.png"><link rel="canonical" href="https://blog.huitaiyang.top/2024/09/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4%EF%BC%9AJavaScript(2%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":30,"languages":{"author":"作者: 灰太羊","link":"链接: ","source":"来源: 灰太羊的羊村","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面试突破：JavaScript（2万字长文！！！）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-19 20:45:56'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="./source/css/top_image.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408141635343.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 项目</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/todoList/"><i class="fa-fw fa-solid fa-list-check"></i><span> todo-list</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐播放器</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> 无界智能编辑器</span></a></li><li><a class="site-page child" href="/chatRoom/"><i class="fa-fw fa-solid fa-comments"></i><span> 在线聊天室</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202409191948011.png')"><nav id="nav"><span id="blog-info"><a href="/" title="灰太羊的羊村"><span class="site-name">灰太羊的羊村</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 项目</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/todoList/"><i class="fa-fw fa-solid fa-list-check"></i><span> todo-list</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐播放器</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fa-solid fa-pen-to-square"></i><span> 无界智能编辑器</span></a></li><li><a class="site-page child" href="/chatRoom/"><i class="fa-fw fa-solid fa-comments"></i><span> 在线聊天室</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端面试突破：JavaScript（2万字长文！！！）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-19T11:44:55.000Z" title="发表于 2024-09-19 19:44:55">2024-09-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-19T12:45:56.488Z" title="更新于 2024-09-19 20:45:56">2024-09-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaScript/">JavaScript</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JavaScript/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/">前端面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">29.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>112分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端面试突破：JavaScript（2万字长文！！！）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202409192045024.png"></p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2024/html/40814949/1726739511272-09f93a7f-f48a-40b2-96a5-c6bd80c74252.html">思维导图.html</a></p>
<h1 id="第一章-JavaScript-变量"><a href="#第一章-JavaScript-变量" class="headerlink" title="第一章 JavaScript 变量"></a>第一章 JavaScript 变量</h1><h2 id="var、let、const-的差异？"><a href="#var、let、const-的差异？" class="headerlink" title="var、let、const 的差异？"></a>var、let、const 的差异？</h2><p><code>var</code>、<code>let</code> 和 <code>const</code> 的主要区别在于<strong>作用域、可变性和提升行为</strong>：</p>
<ol>
<li><p><strong>作用域</strong>：</p>
<ul>
<li><code>var</code>：函数作用域，声明的变量在函数内有效。</li>
<li><code>let</code> 和 <code>const</code>：块级作用域，声明的变量仅在块内有效（如 <code>&#123;&#125;</code> 内）。</li>
</ul>
</li>
<li><p><strong>可变性</strong>：</p>
<ul>
<li><code>var</code> 和 <code>let</code>：可以重新赋值。</li>
<li><code>const</code>：不可重新赋值，必须在声明时赋值。</li>
</ul>
</li>
<li><p><strong>提升（Hoisting）</strong> ：</p>
<ul>
<li><code>var</code>：会提升到作用域顶部，但未赋值前值为 <code>undefined</code>。</li>
<li><code>let</code> 和 <code>const</code>：也会提升，但在赋值前无法访问（”暂时性死区”）。</li>
</ul>
</li>
</ol>
<h2 id="谈谈作用域？"><a href="#谈谈作用域？" class="headerlink" title="谈谈作用域？"></a>谈谈作用域？</h2><blockquote>
<p>作用域控制了变量的可见性和生命周期，块级作用域和函数作用域有助于限制变量的范围，避免污染全局作用域。</p>
</blockquote>
<p>作用域（Scope）决定了代码中变量、函数的可访问性和生命周期，通常分为以下几种：</p>
<ol>
<li><p><strong>全局作用域（Global Scope）</strong> ：</p>
<ul>
<li>在任何函数或块外声明的变量、函数都会拥有全局作用域。</li>
<li>这些变量可以在程序的任何地方访问，直到页面或程序关闭。</li>
<li>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVar = <span class="string">&#x27;I am global&#x27;</span>; <span class="comment">// 全局作用域</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数作用域（Function Scope）</strong> ：</p>
<ul>
<li>由函数创建，使用 <code>var</code> 声明的变量属于函数作用域。</li>
<li>函数内的变量只能在该函数内访问，外部无法访问。</li>
<li>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> functionVar = <span class="string">&#x27;I am in a function&#x27;</span>; <span class="comment">// 函数作用域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(functionVar); <span class="comment">// 报错：未定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>块级作用域（Block Scope）</strong> ：</p>
<ul>
<li>由 <code>&#123;&#125;</code> 创建，使用 <code>let</code> 或 <code>const</code> 声明的变量属于块级作用域。</li>
<li>这些变量只能在其块内访问，块外不可访问。</li>
<li>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> blockVar = <span class="string">&#x27;I am in a block&#x27;</span>; <span class="comment">// 块级作用域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(blockVar); <span class="comment">// 报错：未定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>词法作用域（Lexical Scope）</strong> ：</p>
<ul>
<li>JavaScript 中的作用域是词法作用域，这意味着作用域是在代码书写时决定的，而不是在运行时。</li>
<li>嵌套函数可以访问外部函数的变量，但反过来不行。</li>
<li>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> outerVar = <span class="string">&#x27;Outer&#x27;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(outerVar); <span class="comment">// 可以访问外部作用域的变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>作用域链（Scope Chain）</strong> ：</p>
<ul>
<li>当查找变量时，JavaScript 会沿着作用域链向上查找，直到找到变量或到达全局作用域。</li>
<li>如果变量在当前作用域不存在，JavaScript 会继续向上查找。</li>
</ul>
</li>
</ol>
<h2 id="什么是变量提升？"><a href="#什么是变量提升？" class="headerlink" title="什么是变量提升？"></a>什么是变量提升？</h2><blockquote>
<p>变量提升（Hoisting）是指在 JavaScript 中，变量声明（不包括赋值）会被提升到其作用域的顶部进行处理。JavaScript 引擎在执行代码前，会先扫描声明，确保它们可以在代码执行时被访问。</p>
</blockquote>
<h3 id="具体表现"><a href="#具体表现" class="headerlink" title="具体表现"></a>具体表现</h3><ol>
<li><code>var</code> <strong>声明的变量</strong>：</li>
</ol>
<p>等同于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出：undefined</span></span><br><span class="line">x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>var</code> 声明的变量会被提升到函数或全局作用域的顶部，但不会提升赋值部分。未赋值前，变量的值为 <code>undefined</code>。</p>
</li>
<li><p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 输出：undefined</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p><code>let</code> <strong>和</strong> <code>const</code> <strong>声明的变量</strong>：</p>
<ul>
<li><code>let</code> 和 <code>const</code> 也会提升，但它们处于“<strong>暂时性死区（Temporal Dead Zone）</strong> ”，在声明之前无法访问。未声明前访问会报错。</li>
<li>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 报错：y is not defined</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数提升</strong>：</p>
<ul>
<li>函数声明会被完整提升，意味着可以在函数声明之前调用它。</li>
<li>示例：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>(); <span class="comment">// 输出：Hello</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数表达式（如 <code>var</code>、<code>let</code>、<code>const</code> 的函数赋值）不会被提升。</li>
</ul>
<p>	</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">greet</span>(); <span class="comment">// 报错：greet is not a function</span></span><br><span class="line"><span class="keyword">var</span> greet = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>var</code> <strong>声明的变量</strong>：声明被提升，赋值不被提升，默认值 <code>undefined</code>。</li>
<li><code>let</code> <strong>和</strong> <code>const</code>：声明被提升，但会在声明前的暂时性死区内不可访问。</li>
<li><strong>函数声明</strong>：整个函数被提升，可以在声明前调用。</li>
</ul>
<h1 id="第二章-JavaScript-数据类型"><a href="#第二章-JavaScript-数据类型" class="headerlink" title="第二章 JavaScript 数据类型"></a>第二章 JavaScript 数据类型</h1><h2 id="JavaScript-数据类型有哪些？"><a href="#JavaScript-数据类型有哪些？" class="headerlink" title="JavaScript 数据类型有哪些？"></a>JavaScript 数据类型有哪些？</h2><blockquote>
<p>JavaScript 中的数据类型可以分为两大类：<strong>原始类型（Primitive Types）</strong> 和 <strong>引用类型（Reference Types）</strong> 。</p>
</blockquote>
<h3 id="1-原始类型（Primitive-Types）"><a href="#1-原始类型（Primitive-Types）" class="headerlink" title="1. 原始类型（Primitive Types）"></a>1. <strong>原始类型（Primitive Types）</strong></h3><p>这些类型的值是不可变的，存储的是值本身。</p>
<ul>
<li><p><code>Number</code>：表示数字类型，包括整数和浮点数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">let</span> pi = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>String</code>：表示文本数据，由一组字符组成的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Boolean</code>：表示布尔值，只有 <code>true</code> 和 <code>false</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isActive = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Undefined</code>：表示未定义的值。变量声明了但未赋值时默认为 <code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Null</code>：表示空值，通常用于表示变量没有值或对象为空。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Symbol</code>：表示唯一的标识符，常用于对象属性的唯一键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>(<span class="string">&#x27;unique&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>BigInt</code>：用于表示大整数，可以安全地表示大于 <code>Number</code> 类型的范围。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bigInt = <span class="number">1234567890123456789012345678901234567890n</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-引用类型（Reference-Types）"><a href="#2-引用类型（Reference-Types）" class="headerlink" title="2. 引用类型（Reference Types）"></a>2. <strong>引用类型（Reference Types）</strong></h3><p>这些类型的值是可变的，存储的是对象的引用。</p>
<ul>
<li><p><code>Object</code>：对象是键值对的集合。对象类型包含更多的具体类型，如数组、函数等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Array</code>：对象的一种特殊形式，用于存储有序的值列表。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Function</code>：也是对象的一种，表示可调用的代码块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Date</code>、<code>RegExp</code>（正则表达式）、<code>Map</code>、<code>Set</code> 等都是对象类型的扩展。</p>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>原始类型</strong>：<code>Number</code>，<code>String</code>，<code>Boolean</code>，<code>Undefined</code>，<code>Null</code>，<code>Symbol</code>，<code>BigInt</code>。</li>
<li><strong>引用类型</strong>：<code>Object</code>（包括 <code>Array</code>、<code>Function</code>、<code>Date</code>、<code>Map</code> 等）。</li>
</ul>
<h2 id="原始数据类型和引用数据类型的区别？"><a href="#原始数据类型和引用数据类型的区别？" class="headerlink" title="原始数据类型和引用数据类型的区别？"></a>原始数据类型和引用数据类型的区别？</h2><blockquote>
<p>原始数据类型（Primitive Types）和引用数据类型（Reference Types）在 <strong>存储方式</strong>、<strong>赋值方式</strong> 和 <strong>比较方式</strong> 上有明显区别。</p>
</blockquote>
<h3 id="1-存储方式"><a href="#1-存储方式" class="headerlink" title="1. 存储方式"></a>1. <strong>存储方式</strong></h3><ul>
<li><p><strong>原始数据类型</strong>：</p>
<ul>
<li><p>存储的是<strong>值本身</strong>。</p>
</li>
<li><p>数据值直接存放在<strong>栈</strong>内存中（因为原始数据类型占用空间固定，大小可预知）。</p>
</li>
<li><p>变量直接持有值。</p>
</li>
<li><p>例如：</p>
</li>
</ul>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;  <span class="comment">// 变量 `a` 直接存储值 10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用数据类型</strong>：</p>
<ul>
<li><p>存储的是<strong>对象的引用（内存地址）</strong> ，而不是值本身。</p>
</li>
<li><p>对象实际的数据存储在<strong>堆</strong>内存中，栈内存中保存对堆内存中对象的引用地址。</p>
</li>
<li><p>例如：</p>
</li>
</ul>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;  <span class="comment">// 变量 `obj` 存储的是对象的内存地址</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-赋值方式"><a href="#2-赋值方式" class="headerlink" title="2. 赋值方式"></a>2. <strong>赋值方式</strong></h3><ul>
<li><p><strong>原始数据类型</strong>：</p>
<ul>
<li><p>赋值时是<strong>值的拷贝</strong>，每个变量都有自己独立的值。</p>
</li>
<li><p>改变一个变量不会影响另一个变量。</p>
</li>
<li><p>例如：</p>
</li>
</ul>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;  <span class="comment">// `b` 复制了 `a` 的值</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);  <span class="comment">// 仍然是 5，互不影响</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用数据类型</strong>：</p>
<ul>
<li><p>赋值时是<strong>引用的拷贝</strong>，多个变量共享同一个对象的引用。</p>
</li>
<li><p>改变一个变量中的对象，会影响所有指向该对象的变量。</p>
</li>
<li><p>例如：</p>
</li>
</ul>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;  <span class="comment">// `obj2` 拷贝了 `obj1` 的引用</span></span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&#x27;Bob&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>);  <span class="comment">// 输出 &#x27;Bob&#x27;，因为两个变量指向同一个对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-比较方式"><a href="#3-比较方式" class="headerlink" title="3. 比较方式"></a>3. <strong>比较方式</strong></h3><ul>
<li><p><strong>原始数据类型</strong>：</p>
<ul>
<li><p>比较的是<strong>值本身</strong>。</p>
</li>
<li><p>如果两个原始数据类型的变量值相同，则它们相等。</p>
</li>
<li><p>例如：</p>
</li>
</ul>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x === y);  <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用数据类型</strong>：</p>
<ul>
<li><p>比较的是<strong>引用地址</strong>，即使两个对象的内容相同，它们的引用地址不同也会被视为不相等。</p>
</li>
<li><p>例如：</p>
</li>
</ul>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1 === obj2);  <span class="comment">// 输出 false，因为它们是不同的对象，引用不同</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>原始数据类型</strong>：存储值本身，赋值时拷贝值，比较时根据值相等。</li>
<li><strong>引用数据类型</strong>：存储对象的引用，赋值时拷贝引用，比较时根据引用地址是否相同。</li>
</ul>
<h2 id="为什么-0-1-0-2-0-3-？"><a href="#为什么-0-1-0-2-0-3-？" class="headerlink" title="为什么 0.1 + 0.2 !&#x3D;&#x3D; 0.3 ？"></a>为什么 0.1 + 0.2 !&#x3D;&#x3D; 0.3 ？</h2><blockquote>
<p>在 JavaScript 中，<code>0.1 + 0.2 !== 0.3</code> 这个问题源于浮点数的表示精度问题。计算机中的浮点数使用二进制（基于 IEEE 754 标准）来表示，某些十进制数不能被精确表示为二进制数，因此会产生精度误差。</p>
</blockquote>
<h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><ol>
<li><p><strong>浮点数表示精度</strong>：</p>
<ul>
<li>浮点数在计算机中以有限的二进制位存储，但有些十进制数（如 <code>0.1</code> 和 <code>0.2</code>）在二进制中无法精确表示。</li>
<li>例如，<code>0.1</code> 的二进制表示为 <code>0.00011001100110011001100110011001100110011001100110011...</code>（无限循环）。在有限的位数中表示时，会出现精度丢失。</li>
</ul>
</li>
<li><p><strong>计算结果误差</strong>：</p>
<ul>
<li>当计算 <code>0.1 + 0.2</code> 时，实际上会得到一个接近但不完全等于 <code>0.3</code> 的结果。这就是为什么 <code>0.1 + 0.2</code> 的结果与 <code>0.3</code> 比较时不相等。</li>
</ul>
</li>
</ol>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol>
<li><p><strong>使用四舍五入</strong>：</p>
<ul>
<li>对计算结果进行四舍五入以减少精度误差：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">let</span> isEqual = <span class="title class_">Math</span>.<span class="title function_">abs</span>(result - <span class="number">0.3</span>) &lt; <span class="title class_">Number</span>.<span class="property">EPSILON</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isEqual);  <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用精度容差</strong>：</p>
<ul>
<li>允许一些小的误差范围：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">areCloseEnough</span>(<span class="params">a, b, tolerance = <span class="number">1e-10</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(a - b) &lt; tolerance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">areCloseEnough</span>(result, <span class="number">0.3</span>));  <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用整数代替浮点数</strong>：</p>
<ul>
<li>在需要高精度计算时，可以将浮点数转换为整数进行计算：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0.1</span> * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0.2</span> * <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">0.3</span> * <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a + b === c);  <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="谈谈-undefined-和-null-？"><a href="#谈谈-undefined-和-null-？" class="headerlink" title="谈谈 undefined 和 null ？"></a>谈谈 undefined 和 null ？</h2><blockquote>
<p><strong>注意：</strong> <code>undefined == null</code><em><strong>为true，而</strong></em><code>undefined === null</code><em><strong>为false</strong></em></p>
<p>在 JavaScript 中，<code>undefined</code> 和 <code>null</code> 是两个不同的数据类型，它们用于表示“缺失”的概念，但有不同的语义和使用场景：</p>
</blockquote>
<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a><code>undefined</code></h3><ol>
<li><p><strong>定义</strong>：</p>
<ul>
<li><code>undefined</code> 是一种原始数据类型，表示一个变量尚未被赋值。</li>
<li>当变量被声明但没有初始化时，它的值为 <code>undefined</code>。</li>
</ul>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li>用于表示变量或属性的值尚未定义或初始化。</li>
<li>函数未显式返回值时，默认返回 <code>undefined</code>。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);  <span class="comment">// 输出：undefined，因为 `x` 尚未赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>());  <span class="comment">// 输出：undefined，因为 `foo` 没有返回值</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>检测</strong>：</p>
<ul>
<li>可以使用 <code>typeof</code> 来检查是否是 <code>undefined</code>：</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> y;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> y === <span class="string">&#x27;undefined&#x27;</span>);  <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure>

<h3 id="null"><a href="#null" class="headerlink" title="null"></a><code>null</code></h3><ol>
<li><p><strong>定义</strong>：</p>
<ul>
<li><code>null</code> 是一种原始数据类型，表示“空值”或“无值”。</li>
<li>这是一个显式的值，表示一个变量应当有一个对象值，但目前为空。</li>
</ul>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li>通常用作占位符，表示某个变量应该有值，但当前没有值。</li>
<li>用于表示对象的空值或未找到的结果。</li>
</ul>
</li>
<li><p><strong>例子</strong>：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);  <span class="comment">// 输出：null，表示 `obj` 当前为空</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findUser</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果没有找到用户，返回 null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p><strong>检测</strong>：</p>
<ul>
<li>可以直接比较 <code>null</code>：</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(z === <span class="literal">null</span>);  <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure>

<h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a><strong>主要区别</strong></h3><ol>
<li><p><strong>含义</strong>：</p>
<ul>
<li><code>undefined</code> 表示变量尚未被赋值，通常由 JavaScript 引擎自动赋值。</li>
<li><code>null</code> 是由程序员手动赋值，表示“无值”或“空”。</li>
</ul>
</li>
<li><p><strong>类型</strong>：</p>
<ul>
<li><code>undefined</code> 是 <code>undefined</code> 类型。</li>
<li><code>null</code> 是 <code>object</code> 类型（历史遗留问题）。</li>
</ul>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li><code>undefined</code> 通常用于检测变量是否被赋值或函数是否有返回值。</li>
<li><code>null</code> 通常用于表示空值，作为一个占位符，用于初始化对象等场景。</li>
</ul>
</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>undefined</code>：表示变量尚未定义或赋值，由 JavaScript 引擎自动赋值。</li>
<li><code>null</code>：表示空值或无值，由程序员显式赋值，用于指示意图上的空对象或占位符。</li>
</ul>
<h2 id="typeof-null-的结果是什么？"><a href="#typeof-null-的结果是什么？" class="headerlink" title="typeof null 的结果是什么？"></a>typeof null 的结果是什么？</h2><blockquote>
<p>在 JavaScript 中，<code>typeof null</code> 的结果是 <code>&quot;object&quot;</code>。这是由于历史遗留问题造成的。</p>
</blockquote>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ol>
<li><p><strong>历史遗留问题</strong>：</p>
<ul>
<li>在早期的 JavaScript 实现中，<code>null</code> 被设计为一种“对象”类型。这是因为早期的 JavaScript 中，将对象的值存储在一个指向对象的引用中，而 <code>null</code> 被用来表示一个空对象引用。</li>
</ul>
</li>
<li><p><strong>类型检测</strong>：</p>
<ul>
<li><code>typeof</code> 操作符用于检测值的基本数据类型。在最早的 JavaScript 实现中，所有的对象类型（包括 <code>null</code>）都被统一标识为 <code>&quot;object&quot;</code>。</li>
<li>虽然 <code>null</code> 被认为是一个“对象”类型，但它实际上并不是一个对象，而是一个特殊的原始值。</li>
</ul>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);  <span class="comment">// 输出： &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>typeof null</code> 返回 <code>&quot;object&quot;</code> 是由于历史原因的实现细节，这个行为在现代 JavaScript 引擎中仍然保留。为了准确检测 <code>null</code>，应该直接与 <code>null</code> 进行比较：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value === <span class="literal">null</span>);  <span class="comment">// 输出：true</span></span><br></pre></td></tr></table></figure>

<p>通常判断一个变量是对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj !== <span class="literal">null</span>)  <span class="comment">//输出：true</span></span><br></pre></td></tr></table></figure>

<p>这样可以确保正确地判断变量是否为 <code>null</code>。</p>
<h2 id="JavaScript-如何做类型转换？"><a href="#JavaScript-如何做类型转换？" class="headerlink" title="JavaScript 如何做类型转换？"></a>JavaScript 如何做类型转换？</h2><p>JavaScript 提供了多种方法来进行类型转换，将数据从一种类型转换为另一种类型。主要包括以下几种方式：</p>
<h3 id="1-隐式类型转换（自动转换）"><a href="#1-隐式类型转换（自动转换）" class="headerlink" title="1. 隐式类型转换（自动转换）"></a>1. <strong>隐式类型转换（自动转换）</strong></h3><p>JavaScript 会在需要时自动进行类型转换，例如在运算、比较等操作中。</p>
<ul>
<li><strong>字符串拼接</strong>：当与字符串进行拼接时，其他类型会被自动转换为字符串。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;The number is &#x27;</span> + num;  <span class="comment">// 自动转换为 &#x27;The number is 5&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>数值运算</strong>：在进行数值运算时，字符串会被自动转换为数值（如果可能的话）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">&#x27;10&#x27;</span> - <span class="number">5</span>;  <span class="comment">// &#x27;10&#x27; 被转换为数字 10，结果为 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>布尔值转换</strong>：在布尔上下文中（如条件判断），值会被自动转换为布尔值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;text&#x27;</span>) &#123;  <span class="comment">// 非空字符串被转换为 true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;True&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-显式类型转换（手动转换）"><a href="#2-显式类型转换（手动转换）" class="headerlink" title="2. 显式类型转换（手动转换）"></a>2. <strong>显式类型转换（手动转换）</strong></h3><p>JavaScript 提供了多种方法进行显式的类型转换：</p>
<ul>
<li><p><strong>字符串转换</strong>：</p>
<ul>
<li><p><code>String()</code>：将其他类型的值转换为字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="title class_">String</span>(num);  <span class="comment">// &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toString()</code>：对象和原始值（除了 <code>null</code> 和 <code>undefined</code>）都有这个方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">456</span>;</span><br><span class="line"><span class="keyword">let</span> str = num.<span class="title function_">toString</span>();  <span class="comment">// &#x27;456&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数值转换</strong>：</p>
<ul>
<li><p><code>Number()</code>：将其他类型的值转换为数值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="title class_">Number</span>(str);  <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>parseInt()</code>：将字符串解析为整数，支持基数（如二进制、十六进制）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;42&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="built_in">parseInt</span>(str, <span class="number">10</span>);  <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>parseFloat()</code>：将字符串解析为浮点数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;3.14&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="built_in">parseFloat</span>(str);  <span class="comment">// 3.14</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>布尔值转换</strong>：</p>
<ul>
<li><p><code>Boolean()</code>：将其他类型的值转换为布尔值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> bool = <span class="title class_">Boolean</span>(num);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

</li>
<li><p><code>!!</code>：将其他类型的值转换为布尔值。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> bool = !!num ;  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="3-特殊情况"><a href="#3-特殊情况" class="headerlink" title="3. 特殊情况"></a>3. <strong>特殊情况</strong></h3><ul>
<li><p><code>+</code> <strong>操作符</strong>：</p>
<ul>
<li><p>如果操作数中有字符串，<code>+</code> 操作符会将其他操作数转换为字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">5</span> + <span class="string">&#x27;5&#x27;</span>;  <span class="comment">// &#x27;55&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>==</code> <strong>操作符</strong>：</p>
<ul>
<li><p>在进行非严格比较时（<code>==</code>），JavaScript 会进行类型转换以尝试比较不同类型的值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span> == <span class="string">&#x27;5&#x27;</span>);  <span class="comment">// true，因为 &#x27;5&#x27; 被转换为数字 5</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>隐式转换</strong>：JavaScript 自动进行的类型转换，通常发生在运算和比较时。</li>
<li><strong>显式转换</strong>：使用 <code>String()</code>, <code>Number()</code>, <code>Boolean()</code>, <code>parseInt()</code>, <code>parseFloat()</code> 等函数手动转换数据类型。</li>
<li><strong>特殊情况</strong>：某些操作符（如 <code>+</code> 和 <code>==</code>）会引发自动类型转换。</li>
</ul>
<h2 id="、-和-Object-is-的区别是什么？"><a href="#、-和-Object-is-的区别是什么？" class="headerlink" title="&#x3D;&#x3D;、 &#x3D;&#x3D;&#x3D; 和 Object.is() 的区别是什么？"></a>&#x3D;&#x3D;、 &#x3D;&#x3D;&#x3D; 和 Object.is() 的区别是什么？</h2><p><code>==</code>、<code>===</code> 和 <code>Object.is()</code> 是 JavaScript 中用于比较值的操作符和方法，它们的行为有所不同：</p>
<h3 id="1-（相等操作符）"><a href="#1-（相等操作符）" class="headerlink" title="1. == （相等操作符）"></a>1. <code>==</code> <strong>（相等操作符）</strong></h3><ul>
<li><p><strong>类型转换</strong>：</p>
<ul>
<li><code>==</code> 操作符在比较时会进行类型转换。如果两个值的类型不同，JavaScript 会尝试将它们转换为相同的类型，然后再进行比较。</li>
</ul>
</li>
<li><p><strong>行为</strong>：</p>
<ul>
<li>数字和字符串比较：字符串会被转换为数字。</li>
<li><code>null</code> 和 <code>undefined</code> 相等：<code>null == undefined</code> 是 <code>true</code>。</li>
<li>布尔值比较：布尔值会被转换为数字（<code>true</code> 转换为 <code>1</code>，<code>false</code> 转换为 <code>0</code>）。</li>
<li>对象与原始值比较：对象会被转换为布尔值 <code>true</code>，并进行进一步比较。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span> == <span class="string">&#x27;5&#x27;</span>);       <span class="comment">// true，因为 &#x27;5&#x27; 被转换为数字 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>);  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> == <span class="literal">false</span>);    <span class="comment">// true，因为 false 被转换为数字 0</span></span><br></pre></td></tr></table></figure>

<h3 id="2-（严格相等操作符）"><a href="#2-（严格相等操作符）" class="headerlink" title="2. === （严格相等操作符）"></a>2. <code>===</code> <strong>（严格相等操作符）</strong></h3><ul>
<li><p><strong>类型不转换</strong>：</p>
<ul>
<li><code>===</code> 操作符在比较时不会进行类型转换。如果两个值的类型不同，它们被认为是不相等的。</li>
</ul>
</li>
<li><p><strong>行为</strong>：</p>
<ul>
<li>值和类型都必须相等才会返回 <code>true</code>。</li>
<li>对象的引用比较：两个对象只有在引用相同的内存地址时才被认为相等。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span> === <span class="string">&#x27;5&#x27;</span>);     <span class="comment">// false，因为类型不同</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> === <span class="literal">undefined</span>);  <span class="comment">// false，因为类型不同</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> === <span class="literal">false</span>);  <span class="comment">// false，因为类型不同</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Object-is"><a href="#3-Object-is" class="headerlink" title="3. Object.is()"></a>3. <code>Object.is()</code></h3><ul>
<li><p><strong>无类型转换</strong>：</p>
<ul>
<li><code>Object.is()</code> 进行精确的值比较，没有任何类型转换。</li>
</ul>
</li>
<li><p><strong>行为</strong>：</p>
<ul>
<li>对比 <code>NaN</code>：<code>Object.is(NaN, NaN)</code> 是 <code>true</code>（与 <code>===</code> 不同，<code>NaN</code> 与 <code>NaN</code> 在严格相等比较中是 <code>false</code>）。</li>
<li>对比 <code>-0</code> 和 <code>+0</code>：<code>Object.is(-0, +0)</code> 是 <code>false</code>（与 <code>===</code> 不同，<code>-0</code> 和 <code>+0</code> 在严格相等比较中是 <code>true</code>）。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">5</span>, <span class="number">5</span>));     <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">5</span>, <span class="string">&#x27;5&#x27;</span>));   <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">is</span>(-<span class="number">0</span>, +<span class="number">0</span>));   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>==</code>：相等操作符，进行类型转换后比较值，可能会导致意外结果。</li>
<li><code>===</code>：严格相等操作符，不进行类型转换，值和类型必须完全相等。</li>
<li><code>Object.is()</code>：精确比较两个值，处理 <code>NaN</code> 和 <code>-0</code> &#x2F; <code>+0</code> 的比较与 <code>===</code> 不同，适用于需要精准比较的场景。</li>
</ul>
<h2 id="JavaScript-判断数据类型有哪些方法？"><a href="#JavaScript-判断数据类型有哪些方法？" class="headerlink" title="JavaScript 判断数据类型有哪些方法？"></a>JavaScript 判断数据类型有哪些方法？</h2><h3 id="1-typeof-操作符"><a href="#1-typeof-操作符" class="headerlink" title="1. typeof 操作符"></a>1. <code>typeof</code> <strong>操作符</strong></h3><ul>
<li><strong>用途</strong>：用于判断原始数据类型（如 <code>number</code>、<code>string</code>、<code>boolean</code> 等）和对象类型（如 <code>object</code> 和 <code>function</code>）。</li>
<li><strong>用法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">123</span>);           <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;hello&#x27;</span>);       <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>);          <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>);     <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>);          <span class="comment">// &#x27;object&#x27;  (历史遗留问题)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;); <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;);  <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-instanceof-操作符"><a href="#2-instanceof-操作符" class="headerlink" title="2. instanceof 操作符"></a>2. <code>instanceof</code> <strong>操作符</strong></h3><ul>
<li><strong>用途</strong>：用于判断一个对象是否是某个构造函数的实例，或是否继承自某个构造函数的原型链。</li>
<li><strong>用法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date <span class="keyword">instanceof</span> <span class="title class_">Date</span>);  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Object-prototype-toString-call-方法"><a href="#3-Object-prototype-toString-call-方法" class="headerlink" title="3. Object.prototype.toString.call() 方法"></a>3. <code>Object.prototype.toString.call()</code> <strong>方法</strong></h3><ul>
<li><strong>用途</strong>：提供更精确的对象类型判断，特别是在区分 <code>null</code>、<code>Array</code> 和其他对象类型时非常有用。</li>
<li><strong>用法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">123</span>));           <span class="comment">// &#x27;[object Number]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;hello&#x27;</span>));       <span class="comment">// &#x27;[object String]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>));          <span class="comment">// &#x27;[object Boolean]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>));     <span class="comment">// &#x27;[object Undefined]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>));          <span class="comment">// &#x27;[object Null]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));    <span class="comment">// &#x27;[object Array]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;)); <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;));  <span class="comment">// &#x27;[object Function]&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Array-isArray-方法"><a href="#4-Array-isArray-方法" class="headerlink" title="4. Array.isArray() 方法"></a>4. <code>Array.isArray()</code> <strong>方法</strong></h3><ul>
<li><strong>用途</strong>：专门用于判断一个值是否为数组。</li>
<li><strong>用法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;));        <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="string">&#x27;hello&#x27;</span>));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="5-Number-isNaN-方法"><a href="#5-Number-isNaN-方法" class="headerlink" title="5. Number.isNaN() 方法"></a>5. <code>Number.isNaN()</code> <strong>方法</strong></h3><ul>
<li><strong>用途</strong>：专门用于判断一个值是否是 <code>NaN</code>，避免 <code>isNaN()</code> 的全局函数带来的误判。</li>
<li><strong>用法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>));    <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="number">123</span>));    <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="string">&#x27;NaN&#x27;</span>));  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="6-typeof-与-constructor"><a href="#6-typeof-与-constructor" class="headerlink" title="6. typeof 与 constructor"></a>6. <code>typeof</code> <strong>与</strong> <code>constructor</code></h3><ul>
<li><strong>用途</strong>：结合使用 <code>typeof</code> 和 <code>constructor</code> 属性来判断类型。</li>
<li><strong>用法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="property">constructor</span> === <span class="title class_">Number</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">constructor</span> === <span class="title class_">String</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="7-isFinite-函数"><a href="#7-isFinite-函数" class="headerlink" title="7. isFinite() 函数"></a>7. <code>isFinite()</code> <strong>函数</strong></h3><ul>
<li><strong>用途</strong>：判断一个值是否是有限数值，不包括 <code>Infinity</code>、<code>-Infinity</code> 和 <code>NaN</code>。</li>
<li><strong>用法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(<span class="number">123</span>));       <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(<span class="title class_">Infinity</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(<span class="title class_">NaN</span>));       <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="8-isInteger-方法"><a href="#8-isInteger-方法" class="headerlink" title="8. isInteger() 方法"></a>8. <code>isInteger()</code> <strong>方法</strong></h3><ul>
<li><strong>用途</strong>：判断一个值是否为整数。</li>
<li><strong>用法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">123</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(<span class="number">123.45</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>typeof</code>：适用于基本数据类型和函数判断，但对 <code>null</code> 和数组不够准确。</li>
<li><code>instanceof</code>：用于判断对象是否是某个构造函数的实例，适用于复杂类型的判断。</li>
<li><code>Object.prototype.toString.call()</code>：用于更精确地判断对象类型，包括区分 <code>null</code> 和数组。</li>
<li><code>Array.isArray()</code>：专门用于判断是否为数组。</li>
<li><code>Number.isNaN()</code>：用于判断是否为 <code>NaN</code>，避免全局 <code>isNaN</code> 的误判。</li>
<li><code>isFinite()</code> 和 <code>isInteger()</code>：用于判断数值的具体特性。</li>
</ul>
<h1 id="第三章-操作符"><a href="#第三章-操作符" class="headerlink" title="第三章 操作符"></a>第三章 操作符</h1><h2 id="、-和-是什么？"><a href="#、-和-是什么？" class="headerlink" title="||&#x3D; 、&amp;&amp;&#x3D; 和 ??&#x3D; 是什么？"></a>||&#x3D; 、&amp;&amp;&#x3D; 和 ??&#x3D; 是什么？</h2><blockquote>
<p><code>||=</code>、<code>&amp;&amp;=</code>, 和 <code>??=</code> 是 JavaScript 中的逻辑赋值操作符，这些操作符提供了一种简洁的方式来执行逻辑操作并赋值。它们是在 ECMAScript 2021（ES12）中引入的。</p>
</blockquote>
<h3 id="1-（逻辑或赋值操作符）"><a href="#1-（逻辑或赋值操作符）" class="headerlink" title="1. ||= （逻辑或赋值操作符）"></a>1. <code>||=</code> <strong>（逻辑或赋值操作符）</strong></h3><ul>
<li><p><strong>用途</strong>：如果左侧的操作数是假值（falsy），则将右侧的值赋给左侧的操作数。</p>
</li>
<li><p><strong>行为</strong>：</p>
<ul>
<li>如果左侧的值为假（例如 <code>0</code>、<code>&quot;&quot;</code>、<code>null</code>、<code>undefined</code>、<code>false</code>），则将右侧的值赋给左侧的操作数。</li>
<li>如果左侧的值为真（truthy），则左侧的值保持不变。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">a ||= <span class="number">5</span>;  <span class="comment">// 因为 a 是假值 0，a 现在变为 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">// 输出：5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line">b ||= <span class="number">20</span>;  <span class="comment">// 因为 b 是真值 10，b 保持不变</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);  <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure>

<h3 id="2-（逻辑与赋值操作符）"><a href="#2-（逻辑与赋值操作符）" class="headerlink" title="2. &amp;&amp;= （逻辑与赋值操作符）"></a>2. <code>&amp;&amp;=</code> <strong>（逻辑与赋值操作符）</strong></h3><ul>
<li><p><strong>用途</strong>：如果左侧的操作数是真值（truthy），则将右侧的值赋给左侧的操作数。</p>
</li>
<li><p><strong>行为</strong>：</p>
<ul>
<li>如果左侧的值为真，则将右侧的值赋给左侧的操作数。</li>
<li>如果左侧的值为假，则左侧的值保持不变。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">x &amp;&amp;= <span class="number">10</span>;  <span class="comment">// 因为 x 是真值 5，x 现在变为 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);  <span class="comment">// 输出：10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line">y &amp;&amp;= <span class="number">20</span>;  <span class="comment">// 因为 y 是假值 0，y 保持不变</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y);  <span class="comment">// 输出：0</span></span><br></pre></td></tr></table></figure>

<h3 id="3-（空值合并赋值操作符）"><a href="#3-（空值合并赋值操作符）" class="headerlink" title="3. ??= （空值合并赋值操作符）"></a>3. <code>??=</code> <strong>（空值合并赋值操作符）</strong></h3><ul>
<li><p><strong>用途</strong>：如果左侧的操作数是 <code>null</code> 或 <code>undefined</code>，则将右侧的值赋给左侧的操作数。</p>
</li>
<li><p><strong>行为</strong>：</p>
<ul>
<li>如果左侧的值是 <code>null</code> 或 <code>undefined</code>，则将右侧的值赋给左侧的操作数。</li>
<li>如果左侧的值既不是 <code>null</code> 也不是 <code>undefined</code>，则左侧的值保持不变。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="literal">null</span>;</span><br><span class="line">p ??= <span class="number">10</span>;  <span class="comment">// 因为 p 是 null，p 现在变为 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p);  <span class="comment">// 输出：10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> q = <span class="number">20</span>;</span><br><span class="line">q ??= <span class="number">30</span>;  <span class="comment">// 因为 q 不是 null 或 undefined，q 保持不变</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(q);  <span class="comment">// 输出：20</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>||=</code>：仅当左侧的值为假值时，才将右侧的值赋给左侧的操作数。</li>
<li><code>&amp;&amp;=</code>：仅当左侧的值为真值时，才将右侧的值赋给左侧的操作数。</li>
<li><code>??=</code>：仅当左侧的值为 <code>null</code> 或 <code>undefined</code> 时，才将右侧的值赋给左侧的操作数。</li>
</ul>
<h2 id="可选链-有什么用？"><a href="#可选链-有什么用？" class="headerlink" title="可选链 ?. 有什么用？"></a>可选链 ?. 有什么用？</h2><blockquote>
<p>可选链操作符（<code>?.</code>）是 JavaScript 的一个重要特性，提供了一种简洁的方式来安全地访问嵌套对象属性。它是在 ECMAScript 2020（ES11）中引入的。其主要用途是在访问对象属性时避免因中间某个属性为 <code>null</code> 或 <code>undefined</code> 而导致的错误。</p>
</blockquote>
<h3 id="用途和行为"><a href="#用途和行为" class="headerlink" title="用途和行为"></a><strong>用途和行为</strong></h3><ol>
<li><p><strong>避免中间值为</strong> <code>null</code> <strong>或</strong> <code>undefined</code> <strong>的错误</strong>：</p>
<ul>
<li>当访问深层嵌套的对象属性时，如果中间某个属性可能为 <code>null</code> 或 <code>undefined</code>，使用可选链可以避免出现运行时错误。</li>
</ul>
</li>
<li><p><strong>简化代码</strong>：</p>
<ul>
<li>在传统的访问方式中，通常需要多重条件检查来确保每一级属性都存在。使用可选链可以简化代码，减少显式的检查。</li>
</ul>
</li>
</ol>
<h3 id="语法和示例"><a href="#语法和示例" class="headerlink" title="语法和示例"></a><strong>语法和示例</strong></h3><ul>
<li><p><strong>属性访问</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">profile</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125; &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">profile</span>?.<span class="property">name</span>);  <span class="comment">// 输出：&#x27;Alice&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = &#123; <span class="attr">profile</span>: <span class="literal">null</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user2.<span class="property">profile</span>?.<span class="property">name</span>); <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>?.</code> 可以安全地访问对象的嵌套属性。如果中间某个属性是 <code>null</code> 或 <code>undefined</code>，整个表达式的结果会是 <code>undefined</code>，而不会抛出错误。</li>
</ul>
</li>
<li><p><strong>方法调用</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;Hello!&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">greet</span>?.());  <span class="comment">// 输出：&#x27;Hello!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">greet</span>?.()); <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>?.</code> 可以安全地调用对象的方法。如果方法不存在（即属性为 <code>null</code> 或 <code>undefined</code>），则不会抛出错误，而是返回 <code>undefined</code>。</li>
</ul>
</li>
<li><p><strong>数组索引</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr?.[<span class="number">1</span>]);  <span class="comment">// 输出：2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2?.[<span class="number">1</span>]); <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>?.</code> 可以安全地访问数组的元素。如果数组为 <code>null</code> 或 <code>undefined</code>，则不会抛出错误。</li>
</ul>
</li>
<li><p><strong>链式调用</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123; <span class="attr">user</span>: &#123; <span class="attr">profile</span>: &#123; <span class="attr">email</span>: <span class="string">&#x27;alice@example.com&#x27;</span> &#125; &#125; &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">user</span>?.<span class="property">profile</span>?.<span class="property">email</span>); <span class="comment">// 输出：&#x27;alice@example.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data2 = &#123; <span class="attr">user</span>: <span class="literal">null</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data2.<span class="property">user</span>?.<span class="property">profile</span>?.<span class="property">email</span>); <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可选链可以与其他操作符结合使用，实现复杂的链式访问。</li>
</ul>
</li>
</ul>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>安全访问</strong>：可选链操作符可以安全地访问对象的嵌套属性、调用方法或访问数组元素，避免因中间属性为 <code>null</code> 或 <code>undefined</code> 导致的错误。</li>
<li><strong>简化代码</strong>：减少了显式的条件检查，使代码更加简洁和易读。</li>
<li><strong>适用场景</strong>：特别适用于处理动态或不确定的对象结构，例如在处理 API 响应时。</li>
</ul>
<h1 id="第四章-对象"><a href="#第四章-对象" class="headerlink" title="第四章 对象"></a>第四章 对象</h1><h2 id="JavaScript-创建对象有哪些方式？"><a href="#JavaScript-创建对象有哪些方式？" class="headerlink" title="JavaScript 创建对象有哪些方式？"></a>JavaScript 创建对象有哪些方式？</h2><h3 id="1-字面量方式"><a href="#1-字面量方式" class="headerlink" title="1. 字面量方式"></a>1. <strong>字面量方式</strong></h3><ul>
<li><strong>语法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">key1</span>: value1,</span><br><span class="line">  <span class="attr">key2</span>: value2,</span><br><span class="line">  <span class="comment">// 可以包含方法</span></span><br><span class="line">  <span class="title function_">methodName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p>简单直接，适用于创建静态对象。</p>
</li>
<li><p>支持定义属性和方法。</p>
</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-构造函数方式"><a href="#2-构造函数方式" class="headerlink" title="2. 构造函数方式"></a>2. <strong>构造函数方式</strong></h3><ul>
<li><strong>语法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> alice = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p>适用于创建具有相似结构的多个对象。</p>
</li>
<li><p>可以通过 <code>new</code> 关键字实例化对象。</p>
</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">make, model</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">make</span> = make;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">model</span> = model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCar = <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="string">&#x27;Toyota&#x27;</span>, <span class="string">&#x27;Corolla&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3-Object-create-方法"><a href="#3-Object-create-方法" class="headerlink" title="3. Object.create() 方法"></a>3. <code>Object.create()</code> <strong>方法</strong></h3><ul>
<li><strong>语法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(prototypeObject, &#123;</span><br><span class="line">  <span class="attr">property1</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: value1,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 可以添加更多属性</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p>创建一个新对象，使用指定的原型对象（<code>prototypeObject</code>）。</p>
</li>
<li><p>可以定义新对象的属性和方法。</p>
</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(proto);</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Alice&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-class-语法（ES6-）"><a href="#4-class-语法（ES6-）" class="headerlink" title="4. class 语法（ES6+）"></a>4. <code>class</code> <strong>语法（ES6+）</strong></h3><ul>
<li><strong>语法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> alice = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Alice&#x27;</span>, <span class="number">25</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p>提供面向对象的语法，支持继承和方法。</p>
</li>
<li><p>是基于构造函数的语法糖，使代码更具可读性。</p>
</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> makes a noise.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> barks.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>);</span><br><span class="line">dog.<span class="title function_">speak</span>();  <span class="comment">// 输出：Rex barks.</span></span><br></pre></td></tr></table></figure>

<h3 id="5-Object-构造函数"><a href="#5-Object-构造函数" class="headerlink" title="5. Object 构造函数"></a>5. <code>Object</code> <strong>构造函数</strong></h3><ul>
<li><strong>语法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">key1</span> = value1;</span><br><span class="line">obj.<span class="property">key2</span> = value2;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p>类似于字面量方式，但通过 <code>new Object()</code> 创建。</p>
</li>
<li><p>通常不如字面量方式直观。</p>
</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line">person.<span class="property">age</span> = <span class="number">25</span>;</span><br><span class="line">person.<span class="property">greet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>字面量方式</strong>：直接创建对象，适合静态对象。</li>
<li><strong>构造函数方式</strong>：适合创建多个结构相似的对象。</li>
<li><code>Object.create()</code> <strong>方法</strong>：创建具有指定原型的对象，灵活性高。</li>
<li><code>class</code> <strong>语法</strong>：提供面向对象编程的语法糖，支持继承和方法。</li>
<li><code>Object</code> <strong>构造函数</strong>：创建空对象并添加属性，通常不如字面量方式直观。</li>
</ul>
<h2 id="如何理解继承和原型链？"><a href="#如何理解继承和原型链？" class="headerlink" title="如何理解继承和原型链？"></a>如何理解继承和原型链？</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a><strong>原型链</strong></h3><p><strong>原型链</strong>是 JavaScript 对象继承机制的基础，允许对象通过链式查找的方式访问其父对象的属性和方法。</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h4><ul>
<li><strong>每个对象都有一个内部属性</strong> <code>[[Prototype]]</code>，它指向另一个对象（即对象的原型）。可以通过 <code>Object.getPrototypeOf(obj)</code> 获取一个对象的原型，或者使用 <code>obj.__proto__</code>（不推荐）。</li>
<li><strong>对象的原型本身也有一个原型</strong>，这种链式关系可以一直延续，直到遇到 <code>null</code>。这个链式结构就是原型链。</li>
<li><strong>当访问对象的属性或方法时</strong>，如果对象自身没有该属性或方法，JavaScript 会沿着原型链向上查找，直到找到该属性&#x2F;方法或者到达原型链的末端（<code>null</code>）。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">let</span> animal = &#123;</span><br><span class="line">  <span class="attr">eats</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义另一个对象，animal 是它的原型</span></span><br><span class="line"><span class="keyword">let</span> rabbit = <span class="title class_">Object</span>.<span class="title function_">create</span>(animal);</span><br><span class="line">rabbit.<span class="property">hops</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rabbit.<span class="property">eats</span>); <span class="comment">// true, 从 animal 继承</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rabbit.<span class="property">hops</span>); <span class="comment">// true, rabbit 自身的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(rabbit) === animal); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><p><strong>继承</strong>是在 JavaScript 中实现对象间共享属性和方法的一种机制。它可以通过原型链来实现。</p>
<h4 id="构造函数和原型继承"><a href="#构造函数和原型继承" class="headerlink" title="构造函数和原型继承"></a><strong>构造函数和原型继承</strong></h4><ul>
<li><p><strong>构造函数继承</strong>：通过构造函数创建的对象可以继承其他对象的属性和方法。构造函数可以设置原型来实现继承。</p>
</li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><p><strong>设置原型</strong>：通过修改构造函数的 <code>prototype</code> 属性来实现继承。</p>
</li>
<li><p><code>Object.create()</code> <strong>方法</strong>：创建一个具有指定原型的新对象，从而实现继承。</p>
</li>
<li><p><strong>ES6 类</strong>：使用 <code>class</code> 语法更直观地实现继承。</p>
</li>
</ul>
</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h4><ul>
<li><strong>构造函数继承</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> eats.`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 继承属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 继承方法</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>; <span class="comment">// 修正 constructor</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bark</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> barks.`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>);</span><br><span class="line">dog.<span class="title function_">eat</span>(); <span class="comment">// Rex eats.</span></span><br><span class="line">dog.<span class="title function_">bark</span>(); <span class="comment">// Rex barks.</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>ES6 类继承</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> eats.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> barks.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>);</span><br><span class="line">dog.<span class="title function_">eat</span>(); <span class="comment">// Rex eats.</span></span><br><span class="line">dog.<span class="title function_">bark</span>(); <span class="comment">// Rex barks.</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>原型链</strong>：是 JavaScript 的对象继承机制的底层实现方式，通过原型链，JavaScript 可以在对象上查找属性和方法，直到找到为止。</li>
<li><strong>继承</strong>：利用原型链实现的机制，允许对象之间共享属性和方法。可以通过构造函数、<code>Object.create()</code>、以及 ES6 类语法来实现。</li>
</ul>
<h2 id="继承有哪几种方式？"><a href="#继承有哪几种方式？" class="headerlink" title="继承有哪几种方式？"></a>继承有哪几种方式？</h2><h3 id="1-构造函数继承"><a href="#1-构造函数继承" class="headerlink" title="1. 构造函数继承"></a>1. <strong>构造函数继承</strong></h3><p>构造函数继承是最传统的继承方式，通过构造函数创建对象，并在子类构造函数中调用父类构造函数来继承属性。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p>继承父类的实例属性。</p>
</li>
<li><p>不继承父类原型上的方法。</p>
</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> eats.`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 继承实例属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">name</span>); <span class="comment">// Rex</span></span><br><span class="line">dog.<span class="title function_">eat</span>(); <span class="comment">// 运行时错误：Dog 没有继承 Animal.prototype.eat 方法</span></span><br></pre></td></tr></table></figure>

<h3 id="2-原型链继承"><a href="#2-原型链继承" class="headerlink" title="2. 原型链继承"></a>2. <strong>原型链继承</strong></h3><p>原型链继承是通过将子类的原型设置为父类的实例来实现的，这样子类可以访问父类原型上的属性和方法。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p>继承父类原型上的方法和属性。</p>
</li>
<li><p>子类实例共享父类实例属性（如果父类实例属性是对象）。</p>
</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> eats.`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Animal</span>(); <span class="comment">// 原型链继承</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">name</span>); <span class="comment">// Rex</span></span><br><span class="line">dog.<span class="title function_">eat</span>(); <span class="comment">// Rex eats.</span></span><br></pre></td></tr></table></figure>

<h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. <strong>组合继承</strong></h3><p>组合继承结合了构造函数继承和原型链继承，既可以继承父类的实例属性，又可以继承父类的原型方法。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p>继承父类的实例属性和原型方法。</p>
</li>
<li><p>解决了原型链继承中实例属性共享的问题。</p>
</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> eats.`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name, breed</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); <span class="comment">// 继承实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 继承原型方法</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>; <span class="comment">// 修正 constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>, <span class="string">&#x27;Golden Retriever&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">name</span>); <span class="comment">// Rex</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">breed</span>); <span class="comment">// Golden Retriever</span></span><br><span class="line">dog.<span class="title function_">eat</span>(); <span class="comment">// Rex eats.</span></span><br></pre></td></tr></table></figure>

<h3 id="4-寄生继承"><a href="#4-寄生继承" class="headerlink" title="4. 寄生继承"></a>4. <strong>寄生继承</strong></h3><p>寄生继承通过使用一个函数来创建一个继承自父类实例的新对象，然后用这个对象来作为子类的原型。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p>实现简单，适合轻量级的继承需求。</p>
</li>
<li><p>不如组合继承全面。</p>
</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObject</span>(<span class="params">proto</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = proto;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> eats.`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name, breed</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title function_">createObject</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// 寄生继承</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Dog</span>; <span class="comment">// 修正 constructor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>, <span class="string">&#x27;Golden Retriever&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">name</span>); <span class="comment">// Rex</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">breed</span>); <span class="comment">// Golden Retriever</span></span><br><span class="line">dog.<span class="title function_">eat</span>(); <span class="comment">// Rex eats.</span></span><br></pre></td></tr></table></figure>

<h3 id="5-ES6-类继承"><a href="#5-ES6-类继承" class="headerlink" title="5. ES6 类继承"></a>5. <strong>ES6 类继承</strong></h3><p>ES6 引入了 <code>class</code> 语法，使得继承变得更直观和易读。通过 <code>extends</code> 关键字可以实现类的继承。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li><p>提供了更简洁的语法来实现继承。</p>
</li>
<li><p>支持类的构造函数、方法、静态方法等。</p>
</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> eats.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, breed</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name); <span class="comment">// 调用父类构造函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> barks.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>, <span class="string">&#x27;Golden Retriever&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">name</span>); <span class="comment">// Rex</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">breed</span>); <span class="comment">// Golden Retriever</span></span><br><span class="line">dog.<span class="title function_">eat</span>(); <span class="comment">// Rex eats.</span></span><br><span class="line">dog.<span class="title function_">bark</span>(); <span class="comment">// Rex barks.</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>构造函数继承</strong>：继承实例属性。</li>
<li><strong>原型链继承</strong>：继承原型上的属性和方法。</li>
<li><strong>组合继承</strong>：结合构造函数和原型链继承，全面继承。</li>
<li><strong>寄生继承</strong>：使用一个函数来实现继承，简单但不全面。</li>
<li><strong>ES6 类继承</strong>：提供现代化的继承语法，直观且功能丰富。</li>
</ul>
<h2 id="如何判断一个对象属于某个类？"><a href="#如何判断一个对象属于某个类？" class="headerlink" title="如何判断一个对象属于某个类？"></a>如何判断一个对象属于某个类？</h2><h3 id="1-instanceof-运算符"><a href="#1-instanceof-运算符" class="headerlink" title="1. instanceof 运算符"></a>1. <code>instanceof</code> <strong>运算符</strong></h3><ul>
<li><strong>用途</strong>：判断一个对象是否是某个构造函数的实例，或者是否继承自某个构造函数的原型。</li>
<li><strong>语法</strong>：<code>object instanceof Constructor</code></li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, breed</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>, <span class="string">&#x27;Golden Retriever&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog <span class="keyword">instanceof</span> <span class="title class_">Dog</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog <span class="keyword">instanceof</span> <span class="title class_">Animal</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog <span class="keyword">instanceof</span> <span class="title class_">Object</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-constructor-属性"><a href="#2-constructor-属性" class="headerlink" title="2. constructor 属性"></a>2. <code>constructor</code> <strong>属性</strong></h3><ul>
<li><strong>用途</strong>：通过检查对象的 <code>constructor</code> 属性来判断其是否属于某个类。</li>
<li><strong>语法</strong>：<code>object.constructor === Constructor</code></li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, breed</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>, <span class="string">&#x27;Golden Retriever&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">constructor</span> === <span class="title class_">Dog</span>);      <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">constructor</span> === <span class="title class_">Animal</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Object-getPrototypeOf-方法"><a href="#3-Object-getPrototypeOf-方法" class="headerlink" title="3. Object.getPrototypeOf 方法"></a>3. <code>Object.getPrototypeOf</code> <strong>方法</strong></h3><ul>
<li><strong>用途</strong>：通过检查对象的原型链是否包含某个类的原型来判断。</li>
<li><strong>语法</strong>：<code>Object.getPrototypeOf(object) === Constructor.prototype</code></li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, breed</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">breed</span> = breed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>, <span class="string">&#x27;Golden Retriever&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(dog) === <span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>);      <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(dog) === <span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Symbol-hasInstance-方法"><a href="#4-Symbol-hasInstance-方法" class="headerlink" title="4. Symbol.hasInstance 方法"></a>4. <code>Symbol.hasInstance</code> <strong>方法</strong></h3><ul>
<li><strong>用途</strong>：自定义类的 <code>Symbol.hasInstance</code> 方法以实现自定义的实例判断逻辑。</li>
<li><strong>语法</strong>：<code>Constructor[Symbol.hasInstance](object)</code></li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> [<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> instance <span class="keyword">instanceof</span> <span class="title class_">Animal</span> &amp;&amp; instance.<span class="property">breed</span> !== <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Rex&#x27;</span>, <span class="string">&#x27;Golden Retriever&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog <span class="keyword">instanceof</span> <span class="title class_">Dog</span>); <span class="comment">// true (自定义判断逻辑)</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><code>instanceof</code> <strong>运算符</strong>：最常用且直观的方式，检查对象是否为构造函数的实例。</li>
<li><code>constructor</code> <strong>属性</strong>：检查对象的构造函数是否与目标类匹配。</li>
<li><code>Object.getPrototypeOf</code> <strong>方法</strong>：检查对象的原型是否与目标类的原型匹配。</li>
<li><code>Symbol.hasInstance</code> <strong>方法</strong>：用于自定义实例检查逻辑。</li>
</ul>
<h2 id="Map-和-WeakMap-有什么区别？"><a href="#Map-和-WeakMap-有什么区别？" class="headerlink" title="Map 和 WeakMap 有什么区别？"></a>Map 和 WeakMap 有什么区别？</h2><blockquote>
<p><code>Map</code> 和 <code>WeakMap</code> 都是 JavaScript 中用于存储键值对的集合类型，但它们有一些重要的区别，这些区别主要体现在键的类型、垃圾回收和性能等方面。</p>
</blockquote>
<h3 id="1-键的类型"><a href="#1-键的类型" class="headerlink" title="1. 键的类型"></a>1. <strong>键的类型</strong></h3><ul>
<li><p><code>Map</code>：</p>
<ul>
<li><p>可以使用任何类型的值作为键，包括对象、原始数据类型（如 <code>number</code>、<code>string</code>、<code>boolean</code>）、函数等。</p>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&#x27;number&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(&#123;&#125;, <span class="string">&#x27;object&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>WeakMap</code>：</p>
<ul>
<li><p>只能使用对象作为键（<code>null</code> 不允许作为键），不能使用原始数据类型。</p>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">weakMap.<span class="title function_">set</span>(obj, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"><span class="comment">// weakMap.set(&#x27;key&#x27;, &#x27;value&#x27;); // TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure>

<h3 id="2-垃圾回收"><a href="#2-垃圾回收" class="headerlink" title="2. 垃圾回收"></a>2. <strong>垃圾回收</strong></h3><ul>
<li><p><code>Map</code>：</p>
<ul>
<li><p><code>Map</code> 对其键值对持有强引用，即使键对象不再被使用，<code>Map</code> 中的键值对也不会被垃圾回收。</p>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">map.<span class="title function_">set</span>(obj, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// obj 对象不再被引用，但 map 依然保持对 obj 的引用</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>WeakMap</code></p>
<ul>
<li><p><code>WeakMap</code> 对键对象持有弱引用，这意味着如果一个对象作为键的引用被销毁，<code>WeakMap</code> 可以自动将该键值对从集合中移除，帮助进行垃圾回收。</p>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">weakMap.<span class="title function_">set</span>(obj, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// obj 对象被垃圾回收，weakMap 也会自动删除该键值对</span></span><br></pre></td></tr></table></figure>

<h3 id="3-迭代"><a href="#3-迭代" class="headerlink" title="3. 迭代"></a>3. <strong>迭代</strong></h3><ul>
<li><p><code>Map</code>：</p>
<ul>
<li><p>支持迭代，使用 <code>forEach</code> 方法或者 <code>for...of</code> 循环可以遍历所有的键值对。</p>
</li>
<li><p><strong>示例</strong>：</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;value1&#x27;</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;key2&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// key1 value1</span></span><br><span class="line"><span class="comment">// key2 value2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>WeakMap</code>：<ul>
<li>不支持迭代，因为 <code>WeakMap</code> 的键值对是弱引用的，可能在任何时候被垃圾回收，因此不能提供完整的迭代接口。</li>
</ul>
</li>
</ul>
<h3 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. <strong>应用场景</strong></h3><ul>
<li><p><code>Map</code>：</p>
<ul>
<li><p>适用于需要持久存储键值对的场景，支持各种数据类型作为键。</p>
</li>
<li><p>常用于缓存数据、对象属性存储等。</p>
</li>
</ul>
</li>
<li><p><code>WeakMap</code>：</p>
<ul>
<li><p>适用于存储对象的元数据或关联数据，尤其是当你希望在对象被垃圾回收时自动移除对应的值时。</p>
</li>
<li><p>常用于实现私有属性、缓存对象状态等。</p>
</li>
</ul>
</li>
</ul>
<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>键类型</strong>：<code>Map</code> 可以使用任何类型的键，<code>WeakMap</code> 只能使用对象作为键。</li>
<li><strong>垃圾回收</strong>：<code>Map</code> 持有强引用，<code>WeakMap</code> 持有弱引用，适合对象自动垃圾回收场景。</li>
<li><strong>迭代</strong>：<code>Map</code> 支持迭代，<code>WeakMap</code> 不支持。</li>
<li><strong>应用场景</strong>：<code>Map</code> 适用于各种持久存储需求，<code>WeakMap</code> 适合需要与对象生命周期同步的情况。</li>
</ul>
<h2 id="如何实现深拷贝和浅拷贝？"><a href="#如何实现深拷贝和浅拷贝？" class="headerlink" title="如何实现深拷贝和浅拷贝？"></a>如何实现深拷贝和浅拷贝？</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h3><blockquote>
<p>浅拷贝仅复制对象的第一层属性，对于嵌套的对象属性，它们仍然引用原始对象中的同一个引用。换句话说，浅拷贝不会复制嵌套对象的内容，而是复制它们的引用。</p>
</blockquote>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h4><ol>
<li><p><code>Object.assign()</code></p>
<ul>
<li><strong>用途</strong>：复制一个对象的属性到另一个对象中。</li>
<li><strong>示例</strong>：</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> copy = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, original);</span><br><span class="line"></span><br><span class="line">copy.<span class="property">a</span> = <span class="number">10</span>;</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">20</span>; <span class="comment">// 修改嵌套对象会影响原对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original.<span class="property">a</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>扩展运算符（Spread Operator）</strong></p>
<ul>
<li><strong>用途</strong>：将对象的属性展开到新的对象中。</li>
<li><strong>示例</strong>：</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> copy = &#123; ...original &#125;;</span><br><span class="line"></span><br><span class="line">copy.<span class="property">a</span> = <span class="number">10</span>;</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">20</span>; <span class="comment">// 修改嵌套对象会影响原对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original.<span class="property">a</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a><strong>深拷贝</strong></h3><blockquote>
<p>深拷贝会递归地复制对象的所有层级，包括嵌套的对象。每个层级的对象都会创建新的副本，修改副本不会影响原对象。</p>
</blockquote>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a><strong>常用方法</strong></h4><ol>
<li><p><code>JSON.parse()</code> <strong>和</strong> <code>JSON.stringify()</code></p>
<ul>
<li><strong>用途</strong>：将对象序列化为 JSON 字符串，然后再解析为新的对象。</li>
<li><strong>限制</strong>：<ul>
<li>不能复制函数、<code>undefined</code>、<code>Symbol</code>、<code>Date</code>、<code>RegExp</code>、<code>Map</code>、<code>Set</code> 和循环引用的对象。</li>
<li><strong>示例</strong>：</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> copy = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(original));</span><br><span class="line"></span><br><span class="line">copy.<span class="property">a</span> = <span class="number">10</span>;</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">20</span>; <span class="comment">// 修改嵌套对象不会影响原对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original.<span class="property">a</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>递归函数</strong></p>
<ul>
<li><strong>用途</strong>：手动编写深拷贝逻辑，能够处理更多数据类型和复杂的对象。</li>
<li><strong>示例</strong>：</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj; <span class="comment">// 基本数据类型或 null</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">has</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> map.<span class="title function_">get</span>(obj); <span class="comment">// 循环引用处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> copy = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  map.<span class="title function_">set</span>(obj, copy);</span><br><span class="line">  </span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    copy[key] = <span class="title function_">deepClone</span>(obj[key], map);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> copy = <span class="title function_">deepClone</span>(original);</span><br><span class="line"></span><br><span class="line">copy.<span class="property">a</span> = <span class="number">10</span>;</span><br><span class="line">copy.<span class="property">b</span>.<span class="property">c</span> = <span class="number">20</span>; <span class="comment">// 修改嵌套对象不会影响原对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original.<span class="property">a</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(original.<span class="property">b</span>.<span class="property">c</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><p><strong>浅拷贝</strong>：</p>
<ul>
<li>使用 <code>Object.assign()</code> 或扩展运算符（Spread Operator）。</li>
<li>仅复制第一层属性，嵌套对象的引用保持不变。</li>
</ul>
</li>
<li><p><strong>深拷贝</strong>：</p>
<ul>
<li><p>使用 <code>JSON.parse()</code> 和 <code>JSON.stringify()</code>，适用于简单对象。</p>
</li>
<li><p>使用自定义递归函数，适用于更复杂的对象，能够处理更多数据类型和循环引用。</p>
</li>
</ul>
</li>
</ul>
<h1 id="第五章-函数"><a href="#第五章-函数" class="headerlink" title="第五章 函数"></a>第五章 函数</h1><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><blockquote>
<p>闭包（Closure）是 JavaScript 中的一个重要概念，它允许一个函数访问和操作函数外部的变量，即使在外部函数已经执行完毕之后。闭包是通过函数作用域和词法作用域机制实现的。</p>
</blockquote>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><p>闭包是指一个函数和其相关的变量环境的组合。在 JavaScript 中，当一个函数定义在另一个函数内部时，这个内部函数就可以访问外部函数的变量，即使外部函数已经执行完毕。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h3><ol>
<li><strong>词法作用域</strong>：函数在定义时会绑定它的作用域链，即它可以访问的变量。</li>
<li><strong>闭包</strong>：内部函数可以访问定义在外部函数中的变量，并且这些变量会保存在闭包中。</li>
</ol>
<h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> outerVar = <span class="string">&#x27;I am from outer&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(outerVar); <span class="comment">// 访问外部函数的变量</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> inner; <span class="comment">// 返回内部函数，形成闭包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> innerFunc = <span class="title function_">outer</span>(); <span class="comment">// 调用外部函数，得到内部函数</span></span><br><span class="line"><span class="title function_">innerFunc</span>(); <span class="comment">// 输出: &#x27;I am from outer&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul>
<li><strong>保留变量环境</strong>：即使外部函数已经执行完毕，闭包依然保留了对其变量的访问权限。</li>
<li><strong>数据封装</strong>：闭包可以封装私有数据，防止外部访问。</li>
</ul>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><ol>
<li><p><strong>私有变量</strong>：</p>
<ul>
<li>通过闭包可以创建私有变量和方法，防止外部直接访问或修改。</li>
<li><strong>示例</strong>：</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count++;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">decrement</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count--;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="title function_">createCounter</span>();</span><br><span class="line">counter.<span class="title function_">increment</span>(); <span class="comment">// 1</span></span><br><span class="line">counter.<span class="title function_">increment</span>(); <span class="comment">// 2</span></span><br><span class="line">counter.<span class="title function_">decrement</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>回调函数</strong>：</p>
<ul>
<li>闭包常用于回调函数中，保持对外部状态的引用。</li>
<li><strong>示例</strong>：</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="title function_">makeCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>闭包是函数和其词法作用域的组合，允许内部函数访问外部函数的变量。它在数据封装、回调函数和创建私有变量等场景中非常有用。通过理解闭包，可以更好地控制变量的作用域和生命周期。</p>
<h2 id="this-的指向有哪些？"><a href="#this-的指向有哪些？" class="headerlink" title="this 的指向有哪些？"></a>this 的指向有哪些？</h2><p>在 JavaScript 中，<code>this</code> 的指向是一个常见且复杂的概念，主要取决于 <code>this</code> 被调用的上下文。以下是 <code>this</code> 指向的几种常见情况：</p>
<h3 id="1-全局上下文"><a href="#1-全局上下文" class="headerlink" title="1. 全局上下文"></a>1. <strong>全局上下文</strong></h3><ul>
<li><strong>指向</strong>：在全局上下文中（即在函数之外），<code>this</code> 指向全局对象（在浏览器中是 <code>window</code>，在 Node.js 中是 <code>global</code>）。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 在浏览器中输出: Window</span></span><br></pre></td></tr></table></figure>

<h3 id="2-函数上下文"><a href="#2-函数上下文" class="headerlink" title="2. 函数上下文"></a>2. <strong>函数上下文</strong></h3><ul>
<li><strong>普通函数</strong>：<ul>
<li><strong>指向</strong>：在普通函数中，<code>this</code> 指向全局对象（在严格模式下是 <code>undefined</code>）。</li>
<li><strong>示例</strong>：</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">show</span>(); <span class="comment">// 在浏览器中输出: Window（严格模式下输出: undefined）</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>箭头函数</strong>：<ul>
<li><strong>指向</strong>：箭头函数不具有自己的 <code>this</code>，它会继承外部函数或全局上下文的 <code>this</code>。</li>
<li><strong>示例</strong>：</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">arrow</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">arrow</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outer</span>(); <span class="comment">// 输出：在浏览器中为全局对象（如果 outer 是全局函数），否则为 outer 函数的 `this`</span></span><br></pre></td></tr></table></figure>

<h3 id="3-对象方法"><a href="#3-对象方法" class="headerlink" title="3. 对象方法"></a>3. <strong>对象方法</strong></h3><ul>
<li><strong>指向</strong>：当 <code>this</code> 出现在对象的方法中时，它指向调用该方法的对象。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// 输出: Alice</span></span><br></pre></td></tr></table></figure>

<h3 id="4-构造函数"><a href="#4-构造函数" class="headerlink" title="4. 构造函数"></a>4. <strong>构造函数</strong></h3><ul>
<li><strong>指向</strong>：在构造函数中，<code>this</code> 指向新创建的实例对象。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Bob&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// 输出: Bob</span></span><br></pre></td></tr></table></figure>

<h3 id="5-call-和-apply-方法"><a href="#5-call-和-apply-方法" class="headerlink" title="5. call 和 apply 方法"></a>5. <code>call</code> <strong>和</strong> <code>apply</code> <strong>方法</strong></h3><ul>
<li><strong>指向</strong>：<code>call</code> 和 <code>apply</code> 方法可以显式地设置 <code>this</code> 的值。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Charlie&#x27;</span> &#125;;</span><br><span class="line">greet.<span class="title function_">call</span>(obj); <span class="comment">// 输出: Charlie</span></span><br></pre></td></tr></table></figure>

<h3 id="6-bind-方法"><a href="#6-bind-方法" class="headerlink" title="6. bind 方法"></a>6. <code>bind</code> <strong>方法</strong></h3><ul>
<li><strong>指向</strong>：<code>bind</code> 方法创建一个新的函数，在该函数中 <code>this</code> 被固定为传入的值。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;Dana&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> boundGreet = greet.<span class="title function_">bind</span>(obj);</span><br><span class="line"><span class="title function_">boundGreet</span>(); <span class="comment">// 输出: Dana</span></span><br></pre></td></tr></table></figure>

<h3 id="7-class-方法"><a href="#7-class-方法" class="headerlink" title="7. class 方法"></a>7. <code>class</code> <strong>方法</strong></h3><ul>
<li><strong>指向</strong>：在 ES6 类的方法中，<code>this</code> 指向类的实例对象。注意，在使用箭头函数作为类方法时，<code>this</code> 会继承外部上下文。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">speak</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> animal = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&#x27;Elephant&#x27;</span>);</span><br><span class="line">animal.<span class="title function_">speak</span>(); <span class="comment">// 输出: Elephant</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>全局上下文</strong>：<code>this</code> 指向全局对象（在严格模式下为 <code>undefined</code>）。</li>
<li><strong>普通函数</strong>：<code>this</code> 指向全局对象（在严格模式下为 <code>undefined</code>）。</li>
<li><strong>箭头函数</strong>：<code>this</code> 继承外部函数或全局上下文的 <code>this</code>。</li>
<li><strong>对象方法</strong>：<code>this</code> 指向调用方法的对象。</li>
<li><strong>构造函数</strong>：<code>this</code> 指向新创建的实例对象。</li>
<li><code>call</code> <strong>和</strong> <code>apply</code>：显式设置 <code>this</code>。</li>
<li><code>bind</code>：创建一个新函数，固定 <code>this</code> 为指定值。</li>
<li><strong>类方法</strong>：<code>this</code> 指向类的实例对象。</li>
</ul>
<h2 id="类数组的转化方式有哪些？"><a href="#类数组的转化方式有哪些？" class="headerlink" title="类数组的转化方式有哪些？"></a>类数组的转化方式有哪些？</h2><blockquote>
<p>在 JavaScript 中，类数组对象（<code>arguments</code>、<code>NodeList</code>、<code>HTMLCollection</code> 等）是一种具有 <code>length</code> 属性和按索引访问元素的对象，但不具有数组的方法。将类数组对象转换为真正的数组可以使用多种方法。</p>
</blockquote>
<h3 id="1-使用-Array-from"><a href="#1-使用-Array-from" class="headerlink" title="1. 使用 Array.from()"></a>1. <strong>使用</strong> <code>Array.from()</code></h3><ul>
<li><strong>用途</strong>：将类数组对象转换为数组。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> args = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">arguments</span>;</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">from</span>(args);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-使用扩展运算符（Spread-Operator）"><a href="#2-使用扩展运算符（Spread-Operator）" class="headerlink" title="2. 使用扩展运算符（Spread Operator）"></a>2. <strong>使用扩展运算符（Spread Operator）</strong></h3><ul>
<li><strong>用途</strong>：利用扩展运算符将类数组对象展开为数组。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> arr = [...nodeList];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出: 一个包含所有 div 元素的数组</span></span><br></pre></td></tr></table></figure>

<h3 id="3-使用-Array-prototype-slice-call"><a href="#3-使用-Array-prototype-slice-call" class="headerlink" title="3. 使用 Array.prototype.slice.call()"></a>3. <strong>使用</strong> <code>Array.prototype.slice.call()</code></h3><ul>
<li><strong>用途</strong>：通过 <code>Array.prototype.slice</code> 方法将类数组对象转换为数组。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> args = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">arguments</span>;</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(args);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-使用-Array-prototype-slice-apply"><a href="#4-使用-Array-prototype-slice-apply" class="headerlink" title="4. 使用 Array.prototype.slice.apply()"></a>4. <strong>使用</strong> <code>Array.prototype.slice.apply()</code></h3><ul>
<li><strong>用途</strong>：通过 <code>apply</code> 方法将 <code>Array.prototype.slice</code> 应用于类数组对象。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">apply</span>(nodeList);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出: 一个包含所有 div 元素的数组</span></span><br></pre></td></tr></table></figure>

<h3 id="5-使用-Array-prototype-concat"><a href="#5-使用-Array-prototype-concat" class="headerlink" title="5. 使用 Array.prototype.concat()"></a>5. <strong>使用</strong> <code>Array.prototype.concat()</code></h3><ul>
<li><strong>用途</strong>：通过 <code>concat</code> 方法将类数组对象转换为数组。此方法的 <code>this</code> 指向一个空数组。</li>
<li><strong>示例</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> args = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">arguments</span>;</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [].<span class="property">concat</span>.<span class="title function_">call</span>([], args);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// 输出: [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><code>Array.from()</code> 和 <strong>扩展运算符</strong> 是现代和简洁的方法，推荐使用。</li>
<li><code>Array.prototype.slice.call()</code> 和 <code>Array.prototype.slice.apply()</code> 是老旧但有效的方法，兼容性好。</li>
<li><code>Array.prototype.concat()</code> 也是一种经典的方法，但略显繁琐。</li>
</ul>
<h2 id="如何模拟实现函数方法：call-、apply-、bind-？"><a href="#如何模拟实现函数方法：call-、apply-、bind-？" class="headerlink" title="如何模拟实现函数方法：call()、apply()、bind()？"></a>如何模拟实现函数方法：call()、apply()、bind()？</h2><h3 id="1-Function-prototype-call"><a href="#1-Function-prototype-call" class="headerlink" title="1. Function.prototype.call()"></a>1. <code>Function.prototype.call()</code></h3><p><code>call()</code> 方法调用一个具有给定 <code>this</code> 值的函数，和参数一起传递。</p>
<h4 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a><strong>模拟实现</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  context = context || globalThis; <span class="comment">// `globalThis` 是全局对象（浏览器中为 `window`，Node.js 中为 `global`）</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>; <span class="comment">// `this` 是调用 `myCall` 的函数</span></span><br><span class="line">  context.<span class="property">fn</span> = fn; <span class="comment">// 将函数赋值给 context 上的新属性</span></span><br><span class="line">  <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...args); <span class="comment">// 调用函数，并传递参数</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>; <span class="comment">// 删除临时属性</span></span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 返回函数执行结果</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting, punctuation</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;greeting&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span><span class="subst">$&#123;punctuation&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span> &#125;;</span><br><span class="line">greet.<span class="title function_">myCall</span>(person, <span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;!&#x27;</span>); <span class="comment">// 输出: Hello, Alice!</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Function-prototype-apply"><a href="#2-Function-prototype-apply" class="headerlink" title="2. Function.prototype.apply()"></a>2. <code>Function.prototype.apply()</code></h3><p><code>apply()</code> 方法调用一个具有给定 <code>this</code> 值的函数，和一个数组（或类似数组对象）作为参数。</p>
<h4 id="模拟实现-1"><a href="#模拟实现-1" class="headerlink" title="模拟实现"></a><strong>模拟实现</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context, args</span>) &#123;</span><br><span class="line">  context = context || globalThis;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  context.<span class="property">fn</span> = fn; <span class="comment">// 将函数赋值给 context 上的新属性</span></span><br><span class="line">  <span class="keyword">const</span> result = context.<span class="title function_">fn</span>(...(args || [])); <span class="comment">// 使用展开运算符传递参数数组</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>; <span class="comment">// 删除临时属性</span></span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 返回函数执行结果</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting, punctuation</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;greeting&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span><span class="subst">$&#123;punctuation&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span> &#125;;</span><br><span class="line">greet.<span class="title function_">myApply</span>(person, [<span class="string">&#x27;Hi&#x27;</span>, <span class="string">&#x27;?&#x27;</span>]); <span class="comment">// 输出: Hi, Bob?</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Function-prototype-bind"><a href="#3-Function-prototype-bind" class="headerlink" title="3. Function.prototype.bind()"></a>3. <code>Function.prototype.bind()</code></h3><p><code>bind()</code> 方法创建一个新函数，当被调用时，它将 <code>this</code> 关键字设置为提供的值，并且预置部分参数。</p>
<h4 id="模拟实现-2"><a href="#模拟实现-2" class="headerlink" title="模拟实现"></a><strong>模拟实现</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context, ...boundArgs</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回一个新函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 使用 `myCall` 方法来调用 `fn`，`this` 是新的上下文</span></span><br><span class="line">    <span class="keyword">return</span> fn.<span class="title function_">myCall</span>(context, ...boundArgs, ...args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">greeting, punctuation</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;greeting&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span><span class="subst">$&#123;punctuation&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">&#x27;Charlie&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> greetCharlie = greet.<span class="title function_">myBind</span>(person, <span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="title function_">greetCharlie</span>(<span class="string">&#x27;!&#x27;</span>); <span class="comment">// 输出: Hello, Charlie!</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><code>call</code>：调用函数，设置 <code>this</code> 值，逐个传递参数。</li>
<li><code>apply</code>：调用函数，设置 <code>this</code> 值，通过数组传递参数。</li>
<li><code>bind</code>：创建一个新函数，预置 <code>this</code> 值和部分参数。</li>
</ul>
<h2 id="立即调用函数表达式（IIFE）有什么特点？"><a href="#立即调用函数表达式（IIFE）有什么特点？" class="headerlink" title="立即调用函数表达式（IIFE）有什么特点？"></a>立即调用函数表达式（IIFE）有什么特点？</h2><blockquote>
<p>立即调用函数表达式（IIFE, Immediately Invoked Function Expression）是一种 JavaScript 编程模式，用于创建一个自执行的函数。</p>
</blockquote>
<h3 id="1-自执行"><a href="#1-自执行" class="headerlink" title="1. 自执行"></a>1. <strong>自执行</strong></h3><p>IIFE 在定义后立即执行。它是一个函数表达式，不是函数声明，因此可以立即调用。</p>
<h3 id="2-创建私有作用域"><a href="#2-创建私有作用域" class="headerlink" title="2. 创建私有作用域"></a>2. <strong>创建私有作用域</strong></h3><p>通过 IIFE 可以创建一个私有作用域，避免了与外部作用域的变量冲突。它可以用于封装代码，隐藏实现细节。</p>
<h3 id="3-避免全局污染"><a href="#3-避免全局污染" class="headerlink" title="3. 避免全局污染"></a>3. <strong>避免全局污染</strong></h3><p>IIFE 常用于避免将变量和函数污染到全局作用域中，保护全局命名空间。</p>
<h3 id="4-使用函数表达式"><a href="#4-使用函数表达式" class="headerlink" title="4. 使用函数表达式"></a>4. <strong>使用函数表达式</strong></h3><p>IIFE 使用函数表达式而不是函数声明，因为函数声明会被提升（hoisted），而函数表达式在定义时不会被提升。</p>
<h3 id="5-支持参数传递"><a href="#5-支持参数传递" class="headerlink" title="5. 支持参数传递"></a>5. <strong>支持参数传递</strong></h3><p>IIFE 可以接受参数，并在内部执行相应的操作。</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a><strong>示例</strong></h3><p><strong>基本用法</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> message = <span class="string">&#x27;Hello, World!&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p><strong>带参数的 IIFE</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b); <span class="comment">// 输出: 3</span></span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><strong>与外部作用域隔离</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> globalVar = <span class="string">&#x27;I am global&#x27;</span>;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> localVar = <span class="string">&#x27;I am local&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(globalVar); <span class="comment">// 输出: I am global</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(localVar); <span class="comment">// 输出: I am local</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(globalVar); <span class="comment">// 输出: I am global</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localVar); <span class="comment">// 报错: localVar is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>自执行</strong>：IIFE 定义后立即执行。</li>
<li><strong>私有作用域</strong>：创建局部作用域，保护全局命名空间。</li>
<li><strong>避免全局污染</strong>：减少全局变量的使用。</li>
<li><strong>使用函数表达式</strong>：利用函数表达式而非函数声明。</li>
</ul>
<p>IIFE 是 JavaScript 中一种常见的编程模式，特别是在需要创建私有作用域和避免全局污染时非常有用。</p>
<h2 id="箭头函数有什么特点？"><a href="#箭头函数有什么特点？" class="headerlink" title="箭头函数有什么特点？"></a>箭头函数有什么特点？</h2><p>箭头函数（Arrow Function）是 ES6 引入的一种简洁的函数定义方式，它具有以下几个主要特点：</p>
<h3 id="1-更简洁的语法"><a href="#1-更简洁的语法" class="headerlink" title="1. 更简洁的语法"></a>1. <strong>更简洁的语法</strong></h3><p>箭头函数使用更简洁的语法，省略了 <code>function</code> 关键字和大括号（在表达式的情况下）。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">add</span> = (<span class="params">x, y</span>) =&gt; x + y;</span><br></pre></td></tr></table></figure>

<h3 id="2-不绑定自己的-this"><a href="#2-不绑定自己的-this" class="headerlink" title="2. 不绑定自己的 this"></a>2. <strong>不绑定自己的</strong> <code>this</code></h3><p>箭头函数不会创建自己的 <code>this</code>，它会继承外部作用域的 <code>this</code>。这对于处理回调函数中的 <code>this</code> 特别有用。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">seconds</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">seconds</span>++; <span class="comment">// `this` 继承自 Timer 对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">seconds</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Timer</span>(); <span class="comment">// 正确地打印秒数</span></span><br></pre></td></tr></table></figure>

<h3 id="3-没有-arguments-对象"><a href="#3-没有-arguments-对象" class="headerlink" title="3. 没有 arguments 对象"></a>3. <strong>没有</strong> <code>arguments</code> <strong>对象</strong></h3><p>箭头函数没有自己的 <code>arguments</code> 对象，<code>arguments</code> 在箭头函数中是不可用的。如果需要访问 <code>arguments</code> 对象，必须使用普通函数。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">normalFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); <span class="comment">// 正常打印 arguments 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrowFunction</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>); <span class="comment">// 报错: arguments is not defined</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">normalFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="title function_">arrowFunction</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-不能用作构造函数"><a href="#4-不能用作构造函数" class="headerlink" title="4. 不能用作构造函数"></a>4. <strong>不能用作构造函数</strong></h3><p>箭头函数不能作为构造函数使用，即不能使用 <code>new</code> 关键字调用它们。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Person</span> = (<span class="params">name</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person(&quot;Alice&quot;); // 报错: Person is not a constructor</span></span><br></pre></td></tr></table></figure>

<h3 id="5-简单的单行函数"><a href="#5-简单的单行函数" class="headerlink" title="5. 简单的单行函数"></a>5. <strong>简单的单行函数</strong></h3><p>如果箭头函数的主体只有一个表达式，可以省略大括号和 <code>return</code> 关键字。这使得简短的函数更简洁。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">square</span> = x =&gt; x * x; <span class="comment">// 单行函数，省略了大括号和 return 关键字</span></span><br></pre></td></tr></table></figure>

<h3 id="6-this-绑定的静态性"><a href="#6-this-绑定的静态性" class="headerlink" title="6. this 绑定的静态性"></a>6. <code>this</code> <strong>绑定的静态性</strong></h3><p>箭头函数中的 <code>this</code> 是在函数定义时静态绑定的，而不是在函数调用时动态绑定的。这使得箭头函数非常适合用于回调函数和闭包中。</p>
<h3 id="7-不具有-prototype-属性"><a href="#7-不具有-prototype-属性" class="headerlink" title="7. 不具有 prototype 属性"></a>7. <strong>不具有</strong> <code>prototype</code> <strong>属性</strong></h3><p>箭头函数没有 <code>prototype</code> 属性，因此不能作为构造函数。</p>
<h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>简洁语法</strong>：使用更简洁的语法来定义函数。</li>
<li><strong>继承</strong> <code>this</code>：<code>this</code> 是从外部作用域继承的，不会创建自己的 <code>this</code>。</li>
<li><strong>无</strong> <code>arguments</code>：没有自己的 <code>arguments</code> 对象。</li>
<li><strong>不能构造</strong>：不能用作构造函数。</li>
<li><strong>简短表达式</strong>：支持简洁的单行函数表达式。</li>
</ul>
<p>箭头函数简化了函数定义的语法，并在处理 <code>this</code> 时提供了一种一致的行为，这使得在回调函数和闭包中使用箭头函数非常方便。</p>
<h2 id="如何实现防抖和节流？"><a href="#如何实现防抖和节流？" class="headerlink" title="如何实现防抖和节流？"></a>如何实现防抖和节流？</h2><blockquote>
<p>防抖（Debounce）和节流（Throttle）是控制函数调用频率的两种常见技术，用于优化性能，尤其是在处理用户输入、滚动事件、窗口调整大小等高频事件时。</p>
</blockquote>
<h3 id="1-防抖（Debounce）"><a href="#1-防抖（Debounce）" class="headerlink" title="1. 防抖（Debounce）"></a>1. <strong>防抖（Debounce）</strong></h3><p>防抖用于限制函数的执行频率，以避免频繁触发函数。它会在事件触发后，延迟执行函数，直到事件停止触发一段时间后再执行。常用于输入框的实时搜索等场景。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h4><ul>
<li>在每次事件触发时，清除上次的定时器。</li>
<li>重新设置一个新的定时器，延迟执行目标函数。</li>
</ul>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">func, wait</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args), wait);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> handleResize = <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Resize event handler&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, handleResize);</span><br></pre></td></tr></table></figure>

<h3 id="2-节流（Throttle）"><a href="#2-节流（Throttle）" class="headerlink" title="2. 节流（Throttle）"></a>2. <strong>节流（Throttle）</strong></h3><p>节流用于控制函数的执行频率，确保函数在指定时间内只执行一次。适用于限制函数调用的频率，以降低高频事件的处理负载。</p>
<h4 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h4><ul>
<li>在函数执行后，设定一个时间间隔，在此时间间隔内不再执行函数。</li>
<li>一旦时间间隔结束，可以再次执行函数。</li>
</ul>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, limit</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> lastFunc;</span><br><span class="line">  <span class="keyword">let</span> lastRan;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!lastRan) &#123;</span><br><span class="line">      func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">      lastRan = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(lastFunc);</span><br><span class="line">      lastFunc = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="title class_">Date</span>.<span class="title function_">now</span>() - lastRan) &gt;= limit) &#123;</span><br><span class="line">          func.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">          lastRan = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, limit - (<span class="title class_">Date</span>.<span class="title function_">now</span>() - lastRan));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">const</span> handleScroll = <span class="title function_">throttle</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Scroll event handler&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, handleScroll);</span><br></pre></td></tr></table></figure>

<h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>防抖</strong>：防止函数在事件频繁触发时多次执行，只有在事件停止触发一段时间后才执行。适用于输入框实时搜索等需要等待用户输入完成后再执行的场景。</li>
<li><strong>节流</strong>：限制函数在一定时间内的执行次数，确保函数在指定时间间隔内只执行一次。适用于滚动、窗口调整大小等高频事件的处理。</li>
</ul>
<h1 id="第六章-Promise-Async-await-Generators"><a href="#第六章-Promise-Async-await-Generators" class="headerlink" title="第六章 Promise &amp; Async&#x2F;await &amp; Generators"></a>第六章 Promise &amp; Async&#x2F;await &amp; Generators</h1><h2 id="如何模拟实现-Promise？"><a href="#如何模拟实现-Promise？" class="headerlink" title="如何模拟实现 Promise？"></a>如何模拟实现 Promise？</h2><blockquote>
<p><code>Promise</code> 是一种用于处理异步操作的对象，它有三种状态：<code>pending</code>（待定）、<code>fulfilled</code>（已完成）和 <code>rejected</code>（已拒绝）。</p>
</blockquote>
<h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h3><ol>
<li><strong>状态管理</strong>：管理 <code>Promise</code> 的状态，确保状态不可变。</li>
<li><strong>回调处理</strong>：支持 <code>then</code> 方法，处理 <code>fulfilled</code> 和 <code>rejected</code> 状态的回调。</li>
<li><strong>链式调用</strong>：支持链式调用 <code>then</code> 方法。</li>
<li><strong>异步执行</strong>：支持异步操作，确保 <code>then</code> 方法中的回调在异步操作完成后执行。</li>
</ol>
<h3 id="模拟实现-3"><a href="#模拟实现-3" class="headerlink" title="模拟实现"></a><strong>模拟实现</strong></h3><p>以下是一个简化的 <code>Promise</code> 实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;pending&#x27;</span>; <span class="comment">// 初始状态</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span>; <span class="comment">// 成功时的值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = <span class="literal">undefined</span>; <span class="comment">// 失败时的原因</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span> = []; <span class="comment">// 成功回调队列</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span> = []; <span class="comment">// 失败回调队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功回调</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">resolve</span> = (<span class="params">value</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="title function_">callback</span>(value));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 失败回调</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">reject</span> = (<span class="params">reason</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">reason</span> = reason;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="title function_">callback</span>(reason));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 executor 函数</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="title function_">executor</span>(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `then` 方法</span></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="comment">// 默认的回调函数</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> value;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123; <span class="keyword">throw</span> reason; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个新的 Promise 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">handleFulfilled</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> result = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>);</span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> <span class="title function_">handleRejected</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> result = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>);</span><br><span class="line">          <span class="title function_">resolve</span>(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理已完成或已拒绝状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;fulfilled&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">handleFulfilled</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span> === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">        <span class="title function_">handleRejected</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onFulfilledCallbacks</span>.<span class="title function_">push</span>(handleFulfilled);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallbacks</span>.<span class="title function_">push</span>(handleRejected);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;Success&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: Success</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Another success&#x27;</span>;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出: Another success</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a><strong>解释</strong></h3><ol>
<li><strong>构造函数</strong>：<code>MyPromise</code> 的构造函数接受一个 <code>executor</code> 函数，该函数接收 <code>resolve</code> 和 <code>reject</code> 两个函数，用于改变 <code>Promise</code> 的状态。</li>
<li><strong>状态管理</strong>：<code>state</code> 属性跟踪 <code>Promise</code> 的状态，初始为 <code>pending</code>，可以变为 <code>fulfilled</code> 或 <code>rejected</code>。</li>
<li><strong>回调队列</strong>：<code>onFulfilledCallbacks</code> 和 <code>onRejectedCallbacks</code> 用于存储回调函数，等待 <code>Promise</code> 状态改变后执行。</li>
<li><code>then</code> <strong>方法</strong>：<code>then</code> 方法返回一个新的 <code>Promise</code> 对象。它接受两个回调函数，一个处理 <code>fulfilled</code> 状态，另一个处理 <code>rejected</code> 状态。回调函数的结果将决定新的 <code>Promise</code> 的状态。</li>
<li><strong>异步处理</strong>：在 <code>then</code> 方法中，根据当前 <code>Promise</code> 的状态决定如何处理回调函数。</li>
</ol>
<p>这只是一个简化版的 <code>Promise</code> 实现，真实的 <code>Promise</code> 规范包括更多细节和优化（如异步执行、微任务队列等）。</p>
<h2 id="简单介绍下-ES6-中的-Iterator-和-Iterable"><a href="#简单介绍下-ES6-中的-Iterator-和-Iterable" class="headerlink" title="简单介绍下 ES6 中的 Iterator 和 Iterable"></a>简单介绍下 ES6 中的 Iterator 和 Iterable</h2><blockquote>
<p>在 ES6 中，<code>Iterator</code>（迭代器）和 <code>Iterable</code>（可迭代对象）是用于遍历数据结构的新机制，它们为像数组、字符串、Set、Map 等集合提供了一种统一的迭代访问方式。</p>
</blockquote>
<h3 id="1-Iterable（可迭代对象）"><a href="#1-Iterable（可迭代对象）" class="headerlink" title="1. Iterable（可迭代对象）"></a>1. <strong>Iterable（可迭代对象）</strong></h3><p>一个对象被称为可迭代对象（<code>Iterable</code>），意味着它实现了 <code>@@iterator</code> 方法（通常是通过 <code>[Symbol.iterator]</code> 属性）。该方法返回一个迭代器对象，供 <code>for...of</code> 循环等操作使用。</p>
<h4 id="常见的可迭代对象"><a href="#常见的可迭代对象" class="headerlink" title="常见的可迭代对象"></a><strong>常见的可迭代对象</strong></h4><ul>
<li>数组（Array）</li>
<li>字符串（String）</li>
<li>Set</li>
<li>Map</li>
<li>类数组对象（如 <code>arguments</code> 对象、<code>NodeList</code>）</li>
<li>自定义可迭代对象</li>
</ul>
<h4 id="示例：数组是可迭代对象"><a href="#示例：数组是可迭代对象" class="headerlink" title="示例：数组是可迭代对象"></a><strong>示例：数组是可迭代对象</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);  <span class="comment">// 输出 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组实现了 <code>Symbol.iterator</code>，因此它是可迭代的，可以使用 <code>for...of</code> 进行遍历。</p>
<h3 id="2-Iterator（迭代器）"><a href="#2-Iterator（迭代器）" class="headerlink" title="2. Iterator（迭代器）"></a>2. <strong>Iterator（迭代器）</strong></h3><p>迭代器是一个对象，具有 <code>next()</code> 方法。每次调用 <code>next()</code> 方法，会返回一个包含 <code>value</code> 和 <code>done</code> 属性的对象：</p>
<ul>
<li><code>value</code>：当前迭代的值。</li>
<li><code>done</code>：布尔值，表示迭代是否完成。如果为 <code>true</code>，表示迭代结束。</li>
</ul>
<h4 id="如何使用迭代器"><a href="#如何使用迭代器" class="headerlink" title="如何使用迭代器"></a><strong>如何使用迭代器</strong></h4><p>可迭代对象的 <code>Symbol.iterator</code> 方法会返回一个迭代器对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> iterator = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]();  <span class="comment">// 获取数组的迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());  <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());  <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());  <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterator.<span class="title function_">next</span>());  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-自定义可迭代对象"><a href="#3-自定义可迭代对象" class="headerlink" title="3. 自定义可迭代对象"></a>3. <strong>自定义可迭代对象</strong></h3><p>可以通过实现 <code>Symbol.iterator</code> 自定义一个可迭代对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myIterable = &#123;</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">data</span>[index++], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 for...of 迭代</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> myIterable) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);  <span class="comment">// 输出 1, 2, 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-23"><a href="#总结-23" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>Iterable</strong>：实现了 <code>Symbol.iterator</code> 方法的对象，允许它们被 <code>for...of</code> 等迭代语法使用。常见的内置可迭代对象包括数组、字符串、Set、Map 等。</li>
<li><strong>Iterator</strong>：通过 <code>next()</code> 方法逐个返回值的对象，直到迭代完成，<code>done</code> 变为 <code>true</code>。</li>
</ul>
<p><code>Iterator</code> 和 <code>Iterable</code> 提供了一个统一的接口来遍历各种数据结构，增强了 ES6 对不同集合类型的操作能力。</p>
<h2 id="谈谈对生成器（Generator）的理解"><a href="#谈谈对生成器（Generator）的理解" class="headerlink" title="谈谈对生成器（Generator）的理解"></a>谈谈对生成器（Generator）的理解</h2><blockquote>
<p>生成器（<code>Generator</code>）是 ES6 引入的一种特殊类型的函数，能够控制函数的执行过程，允许函数暂停执行和恢复。它为异步编程提供了新的思路，同时为创建迭代器提供了简单的语法。</p>
</blockquote>
<h3 id="生成器的特点"><a href="#生成器的特点" class="headerlink" title="生成器的特点"></a><strong>生成器的特点</strong></h3><ol>
<li><strong>可暂停函数</strong>：生成器函数可以在执行过程中暂停，稍后再恢复执行，从暂停的地方继续。生成器通过 <code>yield</code> 关键字来暂停函数的执行。</li>
<li><strong>迭代器接口</strong>：生成器函数返回的是一个迭代器对象，能用 <code>next()</code> 方法来控制执行，并返回一个带有 <code>value</code> 和 <code>done</code> 属性的对象。每次调用 <code>next()</code> 会推进生成器到下一个 <code>yield</code> 表达式。</li>
<li><strong>生成器函数的定义</strong>：生成器函数使用 <code>function*</code> 语法定义，与普通函数不同的是它可以分段执行。</li>
</ol>
<h3 id="生成器函数的语法"><a href="#生成器函数的语法" class="headerlink" title="生成器函数的语法"></a><strong>生成器函数的语法</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span>;  <span class="comment">// 生成器的终点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">generatorFunction</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>()); <span class="comment">// &#123; value: 4, done: true &#125; // 生成器结束，done 为 true</span></span><br></pre></td></tr></table></figure>

<h3 id="生成器的核心概念"><a href="#生成器的核心概念" class="headerlink" title="生成器的核心概念"></a><strong>生成器的核心概念</strong></h3><ol>
<li><p><code>function*</code> <strong>和</strong> <code>yield</code> <strong>关键字</strong>：生成器函数通过 <code>function*</code> 定义，函数执行过程中可以多次暂停，<code>yield</code> 是用来暂停的关键字。</p>
</li>
<li><p><code>next()</code> <strong>方法</strong>：每次调用生成器对象的 <code>next()</code> 方法，生成器从上一个 <code>yield</code> 语句停止的地方继续执行，直到遇到下一个 <code>yield</code> 或者函数结束。<code>next()</code> 方法返回一个对象 <code>&#123; value: ..., done: ... &#125;</code>，其中：</p>
<ul>
<li><code>value</code> 是 <code>yield</code> 语句后面表达式的值。</li>
<li><code>done</code> 是一个布尔值，表示生成器是否执行完成。</li>
</ul>
</li>
<li><p><strong>双向通信</strong>：除了用 <code>next()</code> 启动生成器，外部还可以通过 <code>next(value)</code> 向生成器传递值，生成器内部可以接收外部的传递值。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> first = <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> second = <span class="keyword">yield</span> first + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> second + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">counter</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>());        <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>(<span class="number">10</span>));      <span class="comment">// &#123; value: 12, done: false &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>(<span class="number">20</span>));      <span class="comment">// &#123; value: 23, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="生成器的应用场景"><a href="#生成器的应用场景" class="headerlink" title="生成器的应用场景"></a><strong>生成器的应用场景</strong></h3><ol>
<li><strong>异步编程</strong>：生成器可以用于编写异步代码，以同步的方式描述异步流程（类似 <code>async/await</code> 的思想）。通过 <code>yield</code> 来等待异步操作完成再继续执行。<strong>示例：</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">asyncFlow</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">yield</span> <span class="title function_">fetchData1</span>();  <span class="comment">// 假设 fetchData1 返回 Promise</span></span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">yield</span> <span class="title function_">fetchData2</span>(result1);</span><br><span class="line">  <span class="keyword">return</span> result2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>实现迭代器</strong>：生成器可以用来简化迭代器的实现。<strong>示例：</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">range</span>(<span class="params">start, end</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="title function_">range</span>(<span class="number">1</span>, <span class="number">5</span>)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value); <span class="comment">// 输出 1, 2, 3, 4, 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>控制流</strong>：生成器可以用于复杂的控制流管理，比如任务调度器、协程等。</li>
<li><strong>无限序列生成</strong>：生成器允许你创建无限数据序列，而不会导致内存溢出，因为它们是惰性求值的，只有当你调用 <code>next()</code> 时才会生成下一个值。<strong>示例：</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">infiniteNumbers</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">infiniteNumbers</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gen.<span class="title function_">next</span>().<span class="property">value</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="介绍一下-async-await"><a href="#介绍一下-async-await" class="headerlink" title="介绍一下 async&#x2F;await"></a>介绍一下 async&#x2F;await</h2><blockquote>
<p><code>async/await</code> 是 ES2017 引入的语法，用于简化基于 <code>Promise</code> 的异步操作，使异步代码看起来更像同步代码。它是 <code>Promise</code> 的语法糖，能有效地处理异步代码中的回调地狱问题，让代码更清晰、易读。</p>
</blockquote>
<h3 id="1-async-和-await-的基本概念"><a href="#1-async-和-await-的基本概念" class="headerlink" title="1. async 和 await 的基本概念"></a>1. <code>async</code> <strong>和</strong> <code>await</code> <strong>的基本概念</strong></h3><ul>
<li><code>async</code> <strong>函数</strong>：声明一个 <code>async</code> 函数，意味着这个函数总是返回一个 <code>Promise</code>。如果函数中返回的是非 <code>Promise</code> 的值，JavaScript 会自动将其包装为 <code>Promise.resolve()</code>。</li>
<li><code>await</code> <strong>关键字</strong>：<code>await</code> 只能在 <code>async</code> 函数中使用，它会暂停 <code>async</code> 函数的执行，等待一个 <code>Promise</code> 完成，并返回 <code>Promise</code> 的结果。如果 <code>Promise</code> 被拒绝（<code>rejected</code>），它会抛出异常。</li>
</ul>
<h3 id="2-async-和-await-的用法"><a href="#2-async-和-await-的用法" class="headerlink" title="2. async 和 await 的用法"></a>2. <code>async</code> <strong>和</strong> <code>await</code> <strong>的用法</strong></h3><h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a><strong>简单示例</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetchData</span>().<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data)).<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error));</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>fetchData</code> 是一个 <code>async</code> 函数，它等待 <code>fetch</code> 请求完成，并解析 JSON 数据。<code>await</code> 停止了函数的执行，直到 <code>fetch</code> 完成，保证在继续执行代码之前得到了期望的数据。</p>
<h3 id="3-async-await-的核心特性"><a href="#3-async-await-的核心特性" class="headerlink" title="3. async/await 的核心特性"></a>3. <code>async/await</code> <strong>的核心特性</strong></h3><ul>
<li><strong>简化 Promise 链</strong>：<code>async/await</code> 的一个主要优点是避免了传统 <code>Promise</code> 链式调用（<code>.then().catch()</code>），使代码更加直观。</li>
<li><strong>错误处理</strong>：可以通过 <code>try/catch</code> 块处理 <code>await</code> 的错误，就像同步代码中处理异常一样。<strong>示例：</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchDataWithErrorHandling</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error fetching data:&#x27;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回值</strong>：<code>async</code> 函数总是返回一个 <code>Promise</code>。即使你显式地返回一个普通值，<code>async</code> 函数也会将其包装在一个 <code>Promise</code> 中。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">simpleValue</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">simpleValue</span>().<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value));  <span class="comment">// 输出: 42</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>并行执行</strong>：虽然 <code>await</code> 会暂停 <code>async</code> 函数的执行，但多个 <code>await</code> 表达式可以并行执行，使用 <code>Promise.all</code> 可以有效地并行化异步操作。<strong>示例：</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchDataInParallel</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data1, data2] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data1&#x27;</span>),</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data2&#x27;</span>)</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">const</span> jsonData1 = <span class="keyword">await</span> data1.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">const</span> jsonData2 = <span class="keyword">await</span> data2.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> [jsonData1, jsonData2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-async-await-与-Promise-对比"><a href="#4-async-await-与-Promise-对比" class="headerlink" title="4. async/await 与 Promise 对比"></a>4. <code>async/await</code> <strong>与</strong> <code>Promise</code> <strong>对比</strong></h3><ul>
<li><strong>代码风格</strong>：<code>Promise</code> 通过链式 <code>.then()</code> 和 <code>.catch()</code> 处理异步操作，而 <code>async/await</code> 则通过同步风格的写法来管理异步操作，使代码更清晰。</li>
<li><strong>错误处理</strong>：<code>async/await</code> 使用 <code>try/catch</code> 块捕获错误，比 <code>Promise</code> 的 <code>.catch()</code> 链更接近传统的同步代码错误处理方式。</li>
<li><strong>可读性</strong>：<code>async/await</code> 的风格更贴近同步代码，避免了嵌套和回调地狱的问题，让异步操作更直观。</li>
</ul>
<h3 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. <strong>注意事项</strong></h3><ul>
<li><strong>阻塞问题</strong>：<code>await</code> 会暂停 <code>async</code> 函数的执行，直到 <code>Promise</code> 完成。如果在多个 <code>await</code> 表达式之间没有依赖关系，建议使用 <code>Promise.all()</code> 以并行执行异步任务，避免性能问题。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐：顺序执行多个异步操作</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sequentialFetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data1&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data2&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> [data1, data2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：并行执行多个异步操作</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">parallelFetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data1, data2] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data1&#x27;</span>),</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data2&#x27;</span>)</span><br><span class="line">  ]);</span><br><span class="line">  <span class="keyword">return</span> [data1, data2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>顶级 await</strong>：<code>await</code> 只能在 <code>async</code> 函数中使用，不过从 ES2022 开始，JavaScript 支持<strong>顶级</strong> <code>await</code>，这意味着你可以在模块的顶层直接使用 <code>await</code> 而不需要 <code>async</code> 函数包裹。<strong>示例：</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br></pre></td></tr></table></figure>

<h3 id="总结-24"><a href="#总结-24" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><code>async/await</code> 让处理异步操作的代码更加简洁、易读、类似同步代码，解决了传统异步回调地狱的问题。</li>
<li>使用 <code>await</code> 来暂停异步操作，并通过 <code>try/catch</code> 处理错误，让异步编程的代码结构变得更加清晰。</li>
</ul>
<h2 id="如何实现红绿灯效果？"><a href="#如何实现红绿灯效果？" class="headerlink" title="如何实现红绿灯效果？"></a>如何实现红绿灯效果？</h2><h3 id="1-使用-setTimeout-和回调函数"><a href="#1-使用-setTimeout-和回调函数" class="headerlink" title="1. 使用 setTimeout 和回调函数"></a>1. <strong>使用</strong> <code>setTimeout</code> <strong>和回调函数</strong></h3><p>最基础的方式是通过 <code>setTimeout</code> 和回调函数来实现，这样可以保证异步任务按顺序执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">redLight</span>(<span class="params">duration, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Red Light&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(callback, duration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">yellowLight</span>(<span class="params">duration, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Yellow Light&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(callback, duration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greenLight</span>(<span class="params">duration, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Green Light&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(callback, duration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trafficLight</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">redLight</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">yellowLight</span>(<span class="number">1000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">greenLight</span>(<span class="number">2000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">trafficLight</span>(); <span class="comment">// 循环</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">trafficLight</span>();</span><br></pre></td></tr></table></figure>

<h3 id="2-使用-Promise-实现"><a href="#2-使用-Promise-实现" class="headerlink" title="2. 使用 Promise 实现"></a>2. <strong>使用</strong> <code>Promise</code> <strong>实现</strong></h3><p>通过 <code>Promise</code> 的链式调用，能够避免嵌套回调的问题，并使代码更加清晰。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">redLight</span>(<span class="params">duration</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Red Light&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">yellowLight</span>(<span class="params">duration</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Yellow Light&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greenLight</span>(<span class="params">duration</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Green Light&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trafficLight</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">redLight</span>(<span class="number">3000</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">yellowLight</span>(<span class="number">1000</span>))</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">greenLight</span>(<span class="number">2000</span>))</span><br><span class="line">    .<span class="title function_">then</span>(trafficLight); <span class="comment">// 循环</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">trafficLight</span>();</span><br></pre></td></tr></table></figure>

<h3 id="3-使用-async-await-实现"><a href="#3-使用-async-await-实现" class="headerlink" title="3. 使用 async/await 实现"></a>3. <strong>使用</strong> <code>async/await</code> <strong>实现</strong></h3><p><code>async/await</code> 是基于 <code>Promise</code> 的语法糖，可以让代码看起来更像同步代码，易读性更强。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">redLight</span>(<span class="params">duration</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Red Light&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">yellowLight</span>(<span class="params">duration</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Yellow Light&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greenLight</span>(<span class="params">duration</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Green Light&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">trafficLight</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">redLight</span>(<span class="number">3000</span>);   <span class="comment">// 红灯亮3秒</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">yellowLight</span>(<span class="number">1000</span>); <span class="comment">// 黄灯亮1秒</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">greenLight</span>(<span class="number">2000</span>);  <span class="comment">// 绿灯亮2秒</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">trafficLight</span>();</span><br></pre></td></tr></table></figure>

<h3 id="4-使用-Generator-实现"><a href="#4-使用-Generator-实现" class="headerlink" title="4. 使用 Generator 实现"></a>4. <strong>使用</strong> <code>Generator</code> <strong>实现</strong></h3><p>通过 <code>Generator</code> 和 <code>yield</code> 机制，可以按顺序执行异步操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">redLight</span>(<span class="params">duration</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Red Light&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">yellowLight</span>(<span class="params">duration</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Yellow Light&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greenLight</span>(<span class="params">duration</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Green Light&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">lightGenerator</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">redLight</span>(<span class="number">3000</span>);   <span class="comment">// 红灯亮3秒</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">yellowLight</span>(<span class="number">1000</span>); <span class="comment">// 黄灯亮1秒</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">greenLight</span>(<span class="number">2000</span>);  <span class="comment">// 绿灯亮2秒</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> trafficLight = <span class="title function_">lightGenerator</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">generator</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; value &#125; = generator.<span class="title function_">next</span>();</span><br><span class="line">  value.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">run</span>(generator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(trafficLight);</span><br></pre></td></tr></table></figure>

<h3 id="5-使用-setInterval-实现"><a href="#5-使用-setInterval-实现" class="headerlink" title="5. 使用 setInterval 实现"></a>5. <strong>使用</strong> <code>setInterval</code> <strong>实现</strong></h3><p><code>setInterval</code> 可以通过固定的时间间隔来循环执行任务，但需要自己管理状态。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> current = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> lights = [<span class="string">&#x27;Red Light&#x27;</span>, <span class="string">&#x27;Yellow Light&#x27;</span>, <span class="string">&#x27;Green Light&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> durations = [<span class="number">3000</span>, <span class="number">1000</span>, <span class="number">2000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trafficLight</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(lights[current]);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    current = (current + <span class="number">1</span>) % <span class="number">3</span>; <span class="comment">// 切换到下一个灯</span></span><br><span class="line">    <span class="title function_">trafficLight</span>();</span><br><span class="line">  &#125;, durations[current]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">trafficLight</span>();</span><br></pre></td></tr></table></figure>

<h3 id="总结-25"><a href="#总结-25" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>回调函数</strong>：简单但容易造成回调地狱，不适合复杂异步逻辑。</li>
<li><strong>Promise</strong>：避免了回调地狱，更加直观，适合处理链式异步调用。</li>
<li><code>async/await</code>：基于 <code>Promise</code>，使代码像同步一样，易于阅读和维护。</li>
<li><strong>Generator</strong>：可以通过 <code>yield</code> 控制执行顺序，但需要外部调用器来处理。</li>
<li><code>setInterval</code>：虽然可以自动执行，但需要自己管理状态，适合简单的定时任务。</li>
</ul>
<h1 id="第七章-模块（Modules）"><a href="#第七章-模块（Modules）" class="headerlink" title="第七章 模块（Modules）"></a>第七章 模块（Modules）</h1><h2 id="谈谈模块化的发展历程"><a href="#谈谈模块化的发展历程" class="headerlink" title="谈谈模块化的发展历程"></a>谈谈模块化的发展历程</h2><p>JavaScript 模块化的发展经历了多个阶段，从最初没有模块化支持到现代模块化标准的广泛应用。下面简要介绍 JavaScript 模块化的发展历程：</p>
<h3 id="1-早期没有模块化支持"><a href="#1-早期没有模块化支持" class="headerlink" title="1. 早期没有模块化支持"></a>1. <strong>早期没有模块化支持</strong></h3><p>最初的 JavaScript 是为浏览器设计的，只有全局作用域，没有内建的模块化机制。所有脚本文件都共享同一个全局命名空间，容易造成变量冲突、命名污染和维护困难。开发者需要手动管理脚本文件的加载顺序，模块化编程非常不便。</p>
<h3 id="2-IIFE（立即调用函数表达式）与命名空间模式"><a href="#2-IIFE（立即调用函数表达式）与命名空间模式" class="headerlink" title="2. IIFE（立即调用函数表达式）与命名空间模式"></a>2. <strong>IIFE（立即调用函数表达式）与命名空间模式</strong></h3><p>为了避免全局作用域的污染，开发者开始使用 IIFE（立即调用函数表达式）将代码封装在局部作用域内，模拟模块化。这种方法有效地将变量隔离在函数作用域中，避免命名冲突。</p>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable language_">module</span> = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> privateVar = <span class="string">&#x27;I am private&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">publicVar</span>: <span class="string">&#x27;I am public&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="3-CommonJS-模块化"><a href="#3-CommonJS-模块化" class="headerlink" title="3. CommonJS 模块化"></a>3. <strong>CommonJS 模块化</strong></h3><p>随着 Node.js 的流行，JavaScript 在服务器端的使用越来越广泛。Node.js 引入了 <strong>CommonJS</strong> 规范，定义了一种模块化的方式。每个文件都是一个模块，使用 <code>require</code> 引入模块，用 <code>module.exports</code> 导出模块内容。</p>
<p><strong>特点：</strong></p>
<ul>
<li>主要用于服务器端的模块化。</li>
<li>模块是同步加载的，适合服务器端使用。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">add</span>: <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="4-AMD（Asynchronous-Module-Definition）"><a href="#4-AMD（Asynchronous-Module-Definition）" class="headerlink" title="4. AMD（Asynchronous Module Definition）"></a>4. <strong>AMD（Asynchronous Module Definition）</strong></h3><p>为了应对浏览器环境中模块加载的异步需求，<strong>AMD</strong> 规范被提出。<strong>RequireJS</strong> 是 AMD 的一个实现，允许在浏览器中异步加载模块，解决了 CommonJS 同步加载在浏览器中的不足。</p>
<p><strong>特点：</strong></p>
<ul>
<li>模块异步加载，适合前端使用。</li>
<li>解决了浏览器端加载时间较长的问题。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 AMD 规范</span></span><br><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;math&#x27;</span>], <span class="keyword">function</span>(<span class="params">math</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-UMD（Universal-Module-Definition）"><a href="#5-UMD（Universal-Module-Definition）" class="headerlink" title="5. UMD（Universal Module Definition）"></a>5. <strong>UMD（Universal Module Definition）</strong></h3><p><strong>UMD</strong> 是一种兼容 AMD 和 CommonJS 的模块化标准。它尝试统一服务器端和浏览器端的模块化模式，目的是让同一个模块在不同的环境中都能运行。</p>
<p><strong>特点：</strong></p>
<ul>
<li>兼容性好，支持 AMD、CommonJS 和全局变量模式。</li>
<li>适用于跨平台的 JavaScript 库。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params">root, factory</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">    <span class="comment">// AMD</span></span><br><span class="line">    <span class="title function_">define</span>([], factory);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Node, CommonJS-like</span></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">factory</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Browser globals (root is window)</span></span><br><span class="line">    root.<span class="property">myModule</span> = <span class="title function_">factory</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="variable language_">this</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">sayHello</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="6-ES6-模块化（ES-Module）"><a href="#6-ES6-模块化（ES-Module）" class="headerlink" title="6. ES6 模块化（ES Module）"></a>6. <strong>ES6 模块化（ES Module）</strong></h3><p>在 ECMAScript 2015（ES6）中，JavaScript 原生支持了模块化。ES6 模块通过 <code>import</code> 和 <code>export</code> 关键字实现了模块的引入和导出，支持静态分析，更加现代和高效。</p>
<p><strong>特点：</strong></p>
<ul>
<li>原生支持，成为标准，现代浏览器和 Node.js 都支持。</li>
<li>支持静态分析和树摇优化（Tree Shaking），提升性能。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="7-现代模块打包工具"><a href="#7-现代模块打包工具" class="headerlink" title="7. 现代模块打包工具"></a>7. <strong>现代模块打包工具</strong></h3><p>随着前端项目复杂度的提升，模块化逐渐成为开发的必需品。为了解决浏览器对 ES6 模块支持不全面的问题，工具如 <strong>Webpack</strong> 和 <strong>Rollup</strong> 应运而生。它们能够将多个模块打包为单个文件，并支持各种模块化规范，如 CommonJS 和 ES6 模块。</p>
<ul>
<li><strong>Webpack</strong>：提供丰富的插件系统，适合复杂的应用打包。</li>
<li><strong>Rollup</strong>：更侧重于打包小型库，支持 Tree Shaking，减小打包文件体积。</li>
</ul>
<h3 id="8-ESM-in-Node-js"><a href="#8-ESM-in-Node-js" class="headerlink" title="8. ESM in Node.js"></a>8. <strong>ESM in Node.js</strong></h3><p>随着时间的推移，Node.js 也开始逐步支持 ES6 模块化。在 Node.js v12 及以上版本中，已默认支持 ES Modules（ESM），不过在使用时需要将文件名扩展名改为 <code>.mjs</code>，或在 <code>package.json</code> 中设置 <code>&quot;type&quot;: &quot;module&quot;</code>。</p>
<h3 id="总结-26"><a href="#总结-26" class="headerlink" title="总结"></a>总结</h3><p>JavaScript 模块化经历了从没有模块化支持，到 CommonJS、AMD、UMD 以及最终的 ES6 模块化。现在，ES6 模块化逐渐成为主流，结合打包工具如 Webpack，现代 JavaScript 开发已经非常依赖模块化来构建可维护、可扩展的应用。</p>
<h1 id="第八章-Proxy-Reflection"><a href="#第八章-Proxy-Reflection" class="headerlink" title="第八章 Proxy &amp; Reflection"></a>第八章 Proxy &amp; Reflection</h1><h2 id="谈谈-Object-defineProperty-与-Proxy-的区别？"><a href="#谈谈-Object-defineProperty-与-Proxy-的区别？" class="headerlink" title="谈谈 Object.defineProperty 与 Proxy 的区别？"></a>谈谈 Object.defineProperty 与 Proxy 的区别？</h2><p><code>Object.defineProperty</code> 和 <code>Proxy</code> 都是 JavaScript 用来定义对象行为的工具，它们各自有不同的应用场景和能力。以下是二者的主要区别：</p>
<h3 id="1-功能范围"><a href="#1-功能范围" class="headerlink" title="1. 功能范围"></a>1. <strong>功能范围</strong></h3><ul>
<li><code>Object.defineProperty</code>：用于直接在对象上定义或修改某个属性的特性（如可写性、可枚举性、可配置性等），并允许为属性设置 getter 和 setter。它只能作用于对象的单个属性，无法监控对象的整体行为。<strong>功能局限</strong>：只能劫持对象的单个属性的读取和写入行为。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,  <span class="comment">// 不可修改</span></span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span> <span class="comment">// 不可删除或重新配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// John</span></span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;Jane&#x27;</span>; <span class="comment">// 修改无效，属性是不可写的</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Proxy</code>：代理整个对象，可以拦截和重新定义对对象的各种操作，不仅包括属性的读取和写入，还可以拦截函数调用、属性删除、<code>in</code> 操作符检查、<code>Object.keys()</code> 等操作。<strong>功能强大</strong>：不仅可以对对象的单个属性进行拦截，还能劫持对整个对象的所有操作。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting <span class="subst">$&#123;prop&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> target[prop];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting <span class="subst">$&#123;prop&#125;</span> to <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    target[prop] = value;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span>; <span class="comment">// 输出: Getting name</span></span><br><span class="line">proxy.<span class="property">age</span> = <span class="number">30</span>; <span class="comment">// 输出: Setting age to 30</span></span><br></pre></td></tr></table></figure>

<h3 id="2-适用场景"><a href="#2-适用场景" class="headerlink" title="2. 适用场景"></a>2. <strong>适用场景</strong></h3><ul>
<li><p><code>Object.defineProperty</code>：主要用于对对象某个属性进行精细控制，适合在已有的对象上修改或定义具体的属性行为，通常用于数据绑定和观察属性的变化。<strong>常见应用</strong>：</p>
<ul>
<li><p>Vue 2.x 中响应式数据的实现使用 <code>Object.defineProperty</code> 来观察对象属性的变化。</p>
</li>
<li><p>设置不可修改、不可枚举的属性。</p>
</li>
</ul>
</li>
<li><p><code>Proxy</code>：适用于对对象的全面拦截与控制。它提供了比 <code>Object.defineProperty</code> 更灵活和强大的拦截机制，能够处理更广泛的对象操作行为，适合需要对整个对象进行拦截的场景。<strong>常见应用</strong>：</p>
<ul>
<li><p>Vue 3.x 的响应式系统改用 <code>Proxy</code>，因为它可以直接观察到整个对象的变化，不需要逐个遍历对象的属性。</p>
</li>
<li><p>实现 <code>Proxy</code> 可以用于封装、监控、缓存等高级场景，例如拦截函数调用，或者防止外部代码篡改对象行为。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-操作的对象"><a href="#3-操作的对象" class="headerlink" title="3. 操作的对象"></a>3. <strong>操作的对象</strong></h3><ul>
<li><code>Object.defineProperty</code>：只能操作已有的对象，且只能控制该对象上的某个属性，无法拦截非属性的操作（如 <code>Object.keys()</code> 或 <code>delete</code> 操作）。</li>
<li><code>Proxy</code>：不仅可以代理对象，还可以代理函数、数组等其他复杂的数据结构，并且可以拦截任何操作，如读取、写入、删除、函数调用、<code>in</code> 操作符等等。</li>
</ul>
<h3 id="4-性能"><a href="#4-性能" class="headerlink" title="4. 性能"></a>4. <strong>性能</strong></h3><ul>
<li><code>Object.defineProperty</code>：由于只针对某个具体属性，性能开销相对较小，但由于它不能直接监听对象新增的属性，需要手动递归处理深层次对象属性，这在大规模数据处理时效率较低。</li>
<li><code>Proxy</code>：功能强大，但性能开销较大，特别是在频繁进行属性访问、设置和删除时。虽然它能够实现深层次的监听，但由于拦截所有操作，性能可能受到一定影响，特别是在大规模数据处理中。</li>
</ul>
<h3 id="5-支持性"><a href="#5-支持性" class="headerlink" title="5. 支持性"></a>5. <strong>支持性</strong></h3><ul>
<li><code>Object.defineProperty</code>：在 ES5 中引入，支持较早的浏览器环境和 JavaScript 引擎。</li>
<li><code>Proxy</code>：在 ES6 中引入，浏览器的支持范围比 <code>Object.defineProperty</code> 要更晚，可能在某些旧浏览器或 JavaScript 环境中不可用。</li>
</ul>
<h3 id="总结-27"><a href="#总结-27" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>Object.defineProperty</code>：适合对对象的单个属性进行精细化控制，无法拦截整个对象的操作，主要用于属性的读写控制和数据绑定。</li>
<li><code>Proxy</code>：更强大，可以拦截对象的所有操作，适合对整个对象进行全方位的操作控制和代理，功能丰富，但性能开销相对较大。</li>
</ul>
<p>如果需要对整个对象的行为进行全面监控和拦截，<code>Proxy</code> 是更好的选择；如果只需要控制单个属性的行为，<code>Object.defineProperty</code> 就足够了。</p>
<h2 id="Reflect-有什么用？"><a href="#Reflect-有什么用？" class="headerlink" title="Reflect 有什么用？"></a>Reflect 有什么用？</h2><blockquote>
<p><code>Reflect</code> 是 JavaScript 中的一个内置对象，提供了一组静态方法，用于操作对象的属性以及与代理 (<code>Proxy</code>) 对象协同工作。<code>Reflect</code> 中的方法与之前的对象操作（如对象的属性访问、赋值、删除等）有着相同的功能，但通过 <code>Reflect</code> 调用这些方法更加规范且可控。此外，<code>Reflect</code> 的方法与 <code>Proxy</code> 对象一起使用时，可以更容易地实现默认的行为。</p>
</blockquote>
<p>以下是 <code>Reflect</code> 的主要用途和功能：</p>
<h3 id="1-为对象操作提供函数化的标准接口"><a href="#1-为对象操作提供函数化的标准接口" class="headerlink" title="1. 为对象操作提供函数化的标准接口"></a>1. <strong>为对象操作提供函数化的标准接口</strong></h3><blockquote>
<p><code>Reflect</code> 提供了与 JavaScript 操作符（如 <code>delete</code>、<code>in</code>、<code>[]</code> 等）相对应的函数形式。使用 <code>Reflect</code> 的方法可以让对象操作更具可读性和一致性。</p>
</blockquote>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用操作符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> obj); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> obj); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Reflect 提供的函数形式</span></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">has</span>(obj2, <span class="string">&#x27;age&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(obj2, <span class="string">&#x27;age&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">has</span>(obj2, <span class="string">&#x27;age&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="2-与-Proxy-配合使用，提供默认行为"><a href="#2-与-Proxy-配合使用，提供默认行为" class="headerlink" title="2. 与 Proxy 配合使用，提供默认行为"></a>2. <strong>与 Proxy 配合使用，提供默认行为</strong></h3><p><code>Proxy</code> 拦截对象的操作时，通常需要手动处理对象的默认行为。<code>Reflect</code> 提供的操作与默认行为相同，因此可以在 <code>Proxy</code> 中轻松使用 <code>Reflect</code> 来恢复默认行为。</p>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, prop, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Getting property: <span class="subst">$&#123;prop&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop, receiver); <span class="comment">// 使用 Reflect 进行默认的 get 操作</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, prop, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Setting property: <span class="subst">$&#123;prop&#125;</span> to <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value, receiver); <span class="comment">// 使用 Reflect 进行默认的 set 操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span>; <span class="comment">// 输出: Getting property: name</span></span><br><span class="line">proxy.<span class="property">age</span> = <span class="number">30</span>; <span class="comment">// 输出: Setting property: age to 30</span></span><br></pre></td></tr></table></figure>

<h3 id="3-返回操作成功与否的布尔值"><a href="#3-返回操作成功与否的布尔值" class="headerlink" title="3. 返回操作成功与否的布尔值"></a>3. <strong>返回操作成功与否的布尔值</strong></h3><p>与传统的对象操作不同，<code>Reflect</code> 方法在操作对象时会返回 <code>true</code> 或 <code>false</code> 来表示操作是否成功。这对于需要明确知道操作结果的场景非常有用，特别是在代理和元编程中。</p>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> success = <span class="title class_">Reflect</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(success); <span class="comment">// true，表示定义属性成功</span></span><br></pre></td></tr></table></figure>

<h3 id="4-替代一些不推荐直接使用的操作"><a href="#4-替代一些不推荐直接使用的操作" class="headerlink" title="4. 替代一些不推荐直接使用的操作"></a>4. <strong>替代一些不推荐直接使用的操作</strong></h3><p>JavaScript 中有些操作，如使用 <code>Object.defineProperty</code>、<code>delete</code> 等，虽然功能强大，但不够直观。<code>Reflect</code> 提供了更清晰的方式来完成同样的任务。例如，使用 <code>Reflect.deleteProperty</code> 代替直接的 <code>delete</code> 操作。</p>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 delete 操作符</span></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">name</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Reflect.deleteProperty</span></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(obj, <span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-简化函数调用和构造函数调用"><a href="#5-简化函数调用和构造函数调用" class="headerlink" title="5. 简化函数调用和构造函数调用"></a>5. <strong>简化函数调用和构造函数调用</strong></h3><p><code>Reflect.apply</code> 和 <code>Reflect.construct</code> 提供了对函数的调用和构造函数的标准方式，特别适合在动态场景中使用，如当你需要灵活地调用函数或构造函数时。</p>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reflect.apply - 调用函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">apply</span>(sum, <span class="literal">undefined</span>, [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Reflect.construct - 调用构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="title class_">Reflect</span>.<span class="title function_">construct</span>(<span class="title class_">Person</span>, [<span class="string">&#x27;John&#x27;</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<h3 id="6-避免意外行为或错误"><a href="#6-避免意外行为或错误" class="headerlink" title="6. 避免意外行为或错误"></a>6. <strong>避免意外行为或错误</strong></h3><p><code>Reflect</code> 的方法可以防止一些 JavaScript 中不一致的行为。例如，<code>Reflect.set</code> 在无法设置属性时返回 <code>false</code>，而不是像直接赋值那样静默失败。</p>
<p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj); <span class="comment">// 冻结对象，不允许修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> success = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(obj, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;John&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(success); <span class="comment">// false，不允许修改冻结对象的属性</span></span><br></pre></td></tr></table></figure>

<h3 id="常用的-Reflect-方法"><a href="#常用的-Reflect-方法" class="headerlink" title="常用的 Reflect 方法"></a>常用的 <code>Reflect</code> 方法</h3><ul>
<li><code>Reflect.get(target, property, receiver)</code>：获取对象属性。</li>
<li><code>Reflect.set(target, property, value, receiver)</code>：设置对象属性。</li>
<li><code>Reflect.has(target, property)</code>：判断属性是否存在（相当于 <code>in</code> 操作符）。</li>
<li><code>Reflect.deleteProperty(target, property)</code>：删除对象属性（相当于 <code>delete</code> 操作符）。</li>
<li><code>Reflect.ownKeys(target)</code>：获取对象所有键（包括 symbol 键）。</li>
<li><code>Reflect.defineProperty(target, property, descriptor)</code>：定义对象属性（相当于 <code>Object.defineProperty</code>）。</li>
<li><code>Reflect.getPrototypeOf(target)</code>：获取对象的原型。</li>
<li><code>Reflect.setPrototypeOf(target, prototype)</code>：设置对象的原型。</li>
<li><code>Reflect.apply(func, thisArg, args)</code>：调用函数。</li>
<li><code>Reflect.construct(target, args)</code>：调用构造函数。</li>
</ul>
<h3 id="总结-28"><a href="#总结-28" class="headerlink" title="总结"></a>总结</h3><p><code>Reflect</code> 提供了一种更加标准化、函数化的方式来操作对象，它不仅可以与 <code>Proxy</code> 配合，还能简化对象的操作，并且可以防止一些不直观的 JavaScript 行为。<code>Reflect</code> 使得元编程更为简洁，且大大提升了可维护性和代码的健壮性。</p>
<h1 id="第九章-JavaScript-运行时"><a href="#第九章-JavaScript-运行时" class="headerlink" title="第九章 JavaScript 运行时"></a>第九章 JavaScript 运行时</h1><h2 id="谈谈对执行上下文的理解？"><a href="#谈谈对执行上下文的理解？" class="headerlink" title="谈谈对执行上下文的理解？"></a>谈谈对执行上下文的理解？</h2><blockquote>
<p>在 JavaScript 中，执行上下文（Execution Context）是一个重要的概念，用于理解代码是如何在不同的环境中运行的。执行上下文定义了代码执行时的环境，包括变量、函数和对象的作用域。它为代码执行提供了必要的背景信息。</p>
</blockquote>
<h3 id="1-执行上下文的定义"><a href="#1-执行上下文的定义" class="headerlink" title="1. 执行上下文的定义"></a>1. <strong>执行上下文的定义</strong></h3><p>执行上下文是一个抽象的概念，它描述了 JavaScript 代码的执行环境。每当 JavaScript 代码运行时，都会创建一个新的执行上下文，执行上下文会包含代码执行所需的变量、函数和对象。</p>
<h3 id="2-执行上下文的类型"><a href="#2-执行上下文的类型" class="headerlink" title="2. 执行上下文的类型"></a>2. <strong>执行上下文的类型</strong></h3><p>JavaScript 中有几种主要的执行上下文类型：</p>
<ul>
<li><p><strong>全局执行上下文</strong>：</p>
<ul>
<li><p>当 JavaScript 代码第一次执行时，创建全局执行上下文。</p>
</li>
<li><p>这是程序的入口点，用于定义全局变量和函数。</p>
</li>
<li><p>只有一个全局执行上下文存在于 JavaScript 执行栈中。</p>
</li>
</ul>
</li>
<li><p><strong>函数执行上下文</strong>：</p>
<ul>
<li><p>每当一个函数被调用时，都会创建一个新的函数执行上下文。</p>
</li>
<li><p>用于存储函数的局部变量、参数和 <code>this</code> 绑定。</p>
</li>
<li><p>每个函数调用都会创建一个新的函数执行上下文。</p>
</li>
</ul>
</li>
<li><p><strong>块级执行上下文（ES6 引入的块级作用域）</strong> ：</p>
<ul>
<li>与 <code>let</code> 和 <code>const</code> 的块级作用域相关联，在块级作用域（如 <code>if</code>、<code>for</code> 块）中创建。</li>
<li>主要用于块级作用域变量的管理。</li>
</ul>
</li>
</ul>
<h3 id="3-执行上下文的生命周期"><a href="#3-执行上下文的生命周期" class="headerlink" title="3. 执行上下文的生命周期"></a>3. <strong>执行上下文的生命周期</strong></h3><p>执行上下文的生命周期包括以下几个阶段：</p>
<ul>
<li><p><strong>创建阶段</strong>：</p>
<ul>
<li><p><strong>变量对象的创建</strong>：创建一个变量对象（Variable Object, VO），用于存储变量和函数声明。</p>
</li>
<li><p><strong>作用域链的创建</strong>：建立作用域链，确定变量和函数的可访问性。</p>
</li>
<li><p><code>this</code> <strong>绑定</strong>：确定 <code>this</code> 的指向。</p>
</li>
</ul>
</li>
<li><p><strong>执行阶段</strong>：</p>
<ul>
<li><strong>代码执行</strong>：执行代码中的语句，并在变量对象中分配值，处理函数调用等操作。</li>
</ul>
</li>
</ul>
<h3 id="4-作用域链"><a href="#4-作用域链" class="headerlink" title="4. 作用域链"></a>4. <strong>作用域链</strong></h3><p>作用域链是执行上下文中变量和函数的查找机制。每个执行上下文都有一个作用域链，它决定了变量和函数的可访问性。</p>
<ul>
<li><strong>作用域链的形成</strong>：每当创建执行上下文时，会形成一个新的作用域链。函数的执行上下文会包含父作用域的引用，从而形成链式结构。</li>
<li><strong>查找变量</strong>：在访问变量时，首先会在当前执行上下文的作用域链中查找，如果找不到则继续向外层作用域查找，直到全局执行上下文。</li>
</ul>
<h3 id="5-this-绑定"><a href="#5-this-绑定" class="headerlink" title="5. this 绑定"></a>5. <code>this</code> <strong>绑定</strong></h3><ul>
<li><p><strong>全局上下文</strong>：在全局上下文中，<code>this</code> 绑定到全局对象（浏览器中是 <code>window</code>，Node.js 中是 <code>global</code>）。</p>
</li>
<li><p><strong>函数上下文</strong>：在函数执行上下文中，<code>this</code> 的值取决于函数的调用方式：</p>
</li>
<li><p><strong>普通函数调用</strong>：<code>this</code> 绑定到全局对象（严格模式下是 <code>undefined</code>）。</p>
</li>
<li><p><strong>方法调用</strong>：<code>this</code> 绑定到调用方法的对象。</p>
</li>
<li><p><strong>构造函数调用</strong>：<code>this</code> 绑定到新创建的实例对象。</p>
</li>
<li><p><strong>箭头函数</strong>：<code>this</code> 绑定到创建箭头函数时的上下文，即函数定义时的上下文（没有自己的 <code>this</code>）。</p>
</li>
</ul>
<h3 id="6-执行上下文栈"><a href="#6-执行上下文栈" class="headerlink" title="6. 执行上下文栈"></a>6. <strong>执行上下文栈</strong></h3><p>执行上下文栈（Call Stack）是一个用于管理多个执行上下文的栈结构。它遵循先进后出（LIFO）的原则：</p>
<ul>
<li><strong>入栈</strong>：当创建一个新的执行上下文时，将其推入栈中。</li>
<li><strong>出栈</strong>：当当前执行上下文的代码执行完毕后，将其从栈中弹出。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> outerVar = <span class="string">&#x27;I am outer&#x27;</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(outerVar);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>执行 <code>outer</code> 函数时，创建一个 <code>outer</code> 执行上下文并入栈。</li>
<li>在 <code>outer</code> 执行上下文中调用 <code>inner</code> 函数，创建一个 <code>inner</code> 执行上下文并入栈。</li>
<li><code>inner</code> 执行上下文中的代码执行完毕后，<code>inner</code> 执行上下文出栈。</li>
<li><code>outer</code> 执行上下文中的代码执行完毕后，<code>outer</code> 执行上下文出栈。</li>
</ul>
<h3 id="7-执行上下文与闭包"><a href="#7-执行上下文与闭包" class="headerlink" title="7. 执行上下文与闭包"></a>7. <strong>执行上下文与闭包</strong></h3><p>闭包是执行上下文的一种特殊用法。当函数内部定义了一个或多个函数，并返回这些内部函数时，这些内部函数仍然可以访问其外部函数的变量，即使外部函数已经执行完毕。这是因为内部函数保持了对其创建时的执行上下文的引用。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = <span class="title function_">createCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">counter</span>()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>createCounter</code> 的执行上下文在函数返回后已经出栈，但 <code>counter</code> 函数仍然可以访问 <code>count</code> 变量。这是因为 <code>counter</code> 形成了一个闭包，保持了对 <code>createCounter</code> 执行上下文的引用。</p>
<h3 id="总结-29"><a href="#总结-29" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>执行上下文</strong> 是 JavaScript 执行代码的环境，用于存储代码的变量、函数和对象。</li>
<li><strong>全局上下文</strong> 和 <strong>函数上下文</strong> 是最常见的两种上下文类型。</li>
<li><strong>作用域链</strong> 和 <code>this</code> <strong>绑定</strong> 是执行上下文的关键特性。</li>
<li><strong>执行上下文栈</strong> 管理着代码执行的顺序。</li>
<li><strong>闭包</strong> 是执行上下文的一个重要应用，允许函数访问其外部作用域的变量。</li>
</ul>
<h2 id="简单介绍一下垃圾回收机制"><a href="#简单介绍一下垃圾回收机制" class="headerlink" title="简单介绍一下垃圾回收机制"></a>简单介绍一下垃圾回收机制</h2><blockquote>
<p>垃圾回收（Garbage Collection，GC）是自动管理内存的一种机制，目的是释放不再使用的内存资源，从而避免内存泄漏并优化程序的性能。</p>
</blockquote>
<h3 id="1-垃圾回收的目标"><a href="#1-垃圾回收的目标" class="headerlink" title="1. 垃圾回收的目标"></a>1. <strong>垃圾回收的目标</strong></h3><p>垃圾回收的主要目标是自动识别和释放不再使用的内存，以防止内存泄漏并优化程序的内存使用。这些不再使用的内存通常指的是那些不再被任何引用所持有的对象或变量。</p>
<h3 id="2-标记-清除算法"><a href="#2-标记-清除算法" class="headerlink" title="2. 标记-清除算法"></a>2. <strong>标记-清除算法</strong></h3><p>JavaScript 引擎使用的主要垃圾回收算法是标记-清除（Mark-and-Sweep）算法，其基本步骤如下：</p>
<ul>
<li><p><strong>标记阶段</strong>：</p>
<ul>
<li><p>从根对象（如全局对象、活动函数的局部变量、闭包等）开始，遍历所有可以到达的对象。</p>
</li>
<li><p>对这些可达的对象进行标记，标记它们为“活动”状态，即这些对象仍然在使用中。</p>
</li>
</ul>
</li>
<li><p><strong>清除阶段</strong>：</p>
<ul>
<li><p>遍历所有对象，检查哪些对象没有被标记为活动状态。</p>
</li>
<li><p>删除这些未标记的对象，从而释放它们占用的内存。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-引用计数"><a href="#3-引用计数" class="headerlink" title="3. 引用计数"></a>3. <strong>引用计数</strong></h3><p>除了标记-清除算法，JavaScript 还使用了引用计数（Reference Counting）算法：</p>
<ul>
<li><strong>引用计数</strong>：每个对象都有一个引用计数，记录当前有多少引用指向该对象。当引用计数变为零时，表示对象不再被使用，可以安全地释放它的内存。</li>
<li><strong>问题</strong>：引用计数的一个主要问题是无法处理循环引用的情况（即两个或多个对象相互引用），这种情况下即使对象不再使用，它们的引用计数也不会降为零，从而造成内存泄漏。</li>
</ul>
<h3 id="4-分代收集"><a href="#4-分代收集" class="headerlink" title="4. 分代收集"></a>4. <strong>分代收集</strong></h3><p>现代 JavaScript 引擎（如 V8）通常采用分代收集（Generational Collection）策略，这种策略基于以下观察：</p>
<ul>
<li><strong>短生命周期的对象</strong>：大多数对象的生命周期较短（如局部变量），它们在创建后很快就不再使用。</li>
<li><strong>长生命周期的对象</strong>：一些对象（如全局对象和长时间存活的对象）会被长期使用。</li>
</ul>
<p><strong>分代收集策略</strong>将对象分为几个代（代际），如新生代和老生代：</p>
<ul>
<li><strong>新生代</strong>：存储生命周期较短的对象。垃圾回收在这个代上比较频繁，以快速清理那些不再使用的对象。</li>
<li><strong>老生代</strong>：存储生命周期较长的对象。垃圾回收在这个代上不那么频繁，主要关注长时间存活的对象，减少对老生代的回收频率。</li>
</ul>
<h3 id="5-标记-清除和分代收集结合"><a href="#5-标记-清除和分代收集结合" class="headerlink" title="5. 标记-清除和分代收集结合"></a>5. <strong>标记-清除和分代收集结合</strong></h3><p>现代垃圾回收器结合了标记-清除和分代收集策略：</p>
<ul>
<li><strong>新生代使用标记-整理</strong>：在新生代中，标记-清除会在垃圾回收过程中整理对象，回收不再使用的内存。</li>
<li><strong>老生代使用标记-压缩</strong>：在老生代中，标记-清除后还会进行压缩，减少内存碎片，使得连续的内存块更加紧凑，提高内存利用率。</li>
</ul>
<h3 id="6-垃圾回收的触发"><a href="#6-垃圾回收的触发" class="headerlink" title="6. 垃圾回收的触发"></a>6. <strong>垃圾回收的触发</strong></h3><p>垃圾回收通常由 JavaScript 引擎自动管理，触发时机可能是以下情况：</p>
<ul>
<li><strong>内存不足</strong>：当系统检测到内存使用达到一定阈值时，会触发垃圾回收。</li>
<li><strong>内存压力</strong>：在程序执行过程中，如果内存使用较高，也可能触发垃圾回收。</li>
</ul>
<h3 id="7-优化内存使用"><a href="#7-优化内存使用" class="headerlink" title="7. 优化内存使用"></a>7. <strong>优化内存使用</strong></h3><p>尽管垃圾回收是自动的，但我们仍然可以通过一些方法优化内存使用：</p>
<ul>
<li><strong>避免全局变量</strong>：全局变量的生命周期与程序相同，避免不必要的全局变量可以减少内存泄漏的风险。</li>
<li><strong>清理引用</strong>：及时清理不再使用的对象和引用，帮助垃圾回收器更快地释放内存。</li>
<li><strong>小心闭包</strong>：闭包会持有对其外部作用域的引用，可能导致内存泄漏。合理使用闭包，避免不必要的引用。</li>
</ul>
<h3 id="总结-30"><a href="#总结-30" class="headerlink" title="总结"></a>总结</h3><p>垃圾回收是 JavaScript 自动管理内存的机制，主要包括标记-清除算法、引用计数、分代收集等策略。现代 JavaScript 引擎通过结合这些策略来有效管理内存，优化程序的性能和稳定性。</p>
<h2 id="如何判断当前脚本运行在浏览器还是-Node-环境中？"><a href="#如何判断当前脚本运行在浏览器还是-Node-环境中？" class="headerlink" title="如何判断当前脚本运行在浏览器还是 Node 环境中？"></a>如何判断当前脚本运行在浏览器还是 Node 环境中？</h2><p>在 JavaScript 中，有时需要判断代码是运行在浏览器环境还是 Node.js 环境中。以下是几种常见的方法来进行这种判断：</p>
<h3 id="1-检查全局对象"><a href="#1-检查全局对象" class="headerlink" title="1. 检查全局对象"></a>1. <strong>检查全局对象</strong></h3><ul>
<li><strong>浏览器环境</strong>：全局对象通常是 <code>window</code>。</li>
<li><strong>Node.js 环境</strong>：全局对象是 <code>global</code>。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isBrowser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">window</span>.<span class="property">document</span> !== <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isNode</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">global</span>.<span class="property">process</span> !== <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-检查环境特定的属性"><a href="#2-检查环境特定的属性" class="headerlink" title="2. 检查环境特定的属性"></a>2. <strong>检查环境特定的属性</strong></h3><ul>
<li><strong>浏览器环境</strong>：通常可以检查 <code>window</code>、<code>document</code>、<code>navigator</code> 等对象是否存在。</li>
<li><strong>Node.js 环境</strong>：可以检查 <code>process</code>、<code>module</code>、<code>require</code> 等对象是否存在。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkEnvironment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">window</span>.<span class="property">document</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Browser environment</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Running in a browser&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">global</span>.<span class="property">process</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Node.js environment</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Running in Node.js&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Unknown environment&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-检查环境特定的功能或模块"><a href="#3-检查环境特定的功能或模块" class="headerlink" title="3. 检查环境特定的功能或模块"></a>3. <strong>检查环境特定的功能或模块</strong></h3><ul>
<li><strong>浏览器环境</strong>：可以检查 <code>window</code> 对象中的浏览器特有的属性。</li>
<li><strong>Node.js 环境</strong>：可以检查 <code>process</code> 对象中的属性，如 <code>process.version</code>、<code>process.versions</code> 等。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isBrowser</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> <span class="variable language_">window</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">window</span>.<span class="property">document</span> === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isNode</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> process === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> process.<span class="property">versions</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> process.<span class="property">versions</span>.<span class="property">node</span> !== <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-使用-typeof-检查环境特定的模块或对象"><a href="#4-使用-typeof-检查环境特定的模块或对象" class="headerlink" title="4. 使用 typeof 检查环境特定的模块或对象"></a>4. <strong>使用</strong> <code>typeof</code> <strong>检查环境特定的模块或对象</strong></h3><p>在 Node.js 中，尝试访问 <code>require</code> 函数；在浏览器中，尝试访问 <code>window</code> 对象。</p>
<p><strong>示例代码</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">detectEnvironment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">window</span>.<span class="property">document</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Running in a browser&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">global</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">global</span>.<span class="property">process</span> === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Running in Node.js&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Unknown environment&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-使用模块系统特性"><a href="#5-使用模块系统特性" class="headerlink" title="5. 使用模块系统特性"></a>5. <strong>使用模块系统特性</strong></h3><ul>
<li><strong>Browser</strong>: 通常可以检测是否使用了模块化系统（如 ES Modules）。</li>
<li><strong>Node.js</strong>: 使用 <code>require</code> 或 <code>module</code> 相关的属性和方法。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">detectEnvironment</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">window</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">window</span>.<span class="property">document</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Browser environment</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Running in a browser&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">global</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">global</span>.<span class="property">process</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// Node.js environment</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Running in Node.js&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Unknown environment&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-31"><a href="#总结-31" class="headerlink" title="总结"></a>总结</h3><p>通过检查全局对象、环境特定的属性、功能或模块，可以确定代码运行的环境。</p>
<h2 id="JavaScript-事件循环是什么？"><a href="#JavaScript-事件循环是什么？" class="headerlink" title="JavaScript 事件循环是什么？"></a>JavaScript 事件循环是什么？</h2><blockquote>
<p>JavaScript 事件循环（Event Loop）是 JavaScript 运行时（如浏览器或 Node.js）管理和调度异步操作的一种机制。它确保了 JavaScript 单线程环境中异步代码的执行顺序和同步任务的协调。理解事件循环有助于理解 JavaScript 的异步编程和性能优化。</p>
</blockquote>
<h3 id="1-JavaScript-单线程"><a href="#1-JavaScript-单线程" class="headerlink" title="1. JavaScript 单线程"></a>1. <strong>JavaScript 单线程</strong></h3><p>JavaScript 是单线程的，这意味着它一次只能执行一个任务。为了处理异步操作（如事件、定时器、网络请求），JavaScript 使用了事件循环机制来协调和调度这些操作。</p>
<h3 id="2-执行栈（Call-Stack）"><a href="#2-执行栈（Call-Stack）" class="headerlink" title="2. 执行栈（Call Stack）"></a>2. <strong>执行栈（Call Stack）</strong></h3><p>执行栈是一个 LIFO（Last In, First Out）结构，用于管理和执行代码。每当调用一个函数时，它会被推入栈中；函数执行完毕后，它会被从栈中弹出。</p>
<h3 id="3-任务队列（Task-Queue）"><a href="#3-任务队列（Task-Queue）" class="headerlink" title="3. 任务队列（Task Queue）"></a>3. <strong>任务队列（Task Queue）</strong></h3><p>任务队列（也称为消息队列或事件队列）用于存储异步操作的回调函数。异步操作完成后，其回调函数会被放入任务队列中，等待事件循环将其取出并执行。</p>
<h3 id="4-微任务队列（Microtask-Queue）"><a href="#4-微任务队列（Microtask-Queue）" class="headerlink" title="4. 微任务队列（Microtask Queue）"></a>4. <strong>微任务队列（Microtask Queue）</strong></h3><p>微任务队列用于存储 Promise 的回调（如 <code>.then</code> 和 <code>.catch</code>），以及其他微任务（如 MutationObserver）。微任务具有比任务队列更高的优先级，会在每次事件循环的宏任务（任务队列）执行前执行。</p>
<h3 id="5-事件循环的工作原理"><a href="#5-事件循环的工作原理" class="headerlink" title="5. 事件循环的工作原理"></a>5. <strong>事件循环的工作原理</strong></h3><p>事件循环的工作原理如下：</p>
<ol>
<li><p><strong>执行栈为空时</strong>：事件循环会检查任务队列和微任务队列是否有待执行的任务。</p>
</li>
<li><p><strong>执行微任务</strong>：</p>
<ul>
<li>事件循环会从微任务队列中取出并执行所有微任务。</li>
<li>微任务会持续执行直到微任务队列为空。</li>
</ul>
</li>
<li><p><strong>执行宏任务</strong>：</p>
<ul>
<li>事件循环会从任务队列中取出一个宏任务（如 <code>setTimeout</code>、<code>setInterval</code> 的回调、I&#x2F;O 操作的回调），并将其放入执行栈中执行。</li>
</ul>
</li>
<li><p><strong>渲染更新</strong>（浏览器环境）：</p>
<ul>
<li>在执行微任务和宏任务之间，浏览器可能会进行 DOM 更新和渲染。</li>
</ul>
</li>
<li><p><strong>重复</strong>：</p>
<ul>
<li>事件循环会重复上述过程，直到所有任务和微任务都被处理完毕。</li>
</ul>
</li>
</ol>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Timeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;End&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Start</span></span><br><span class="line"><span class="title class_">End</span></span><br><span class="line"><span class="title class_">Promise</span></span><br><span class="line"><span class="title class_">Timeout</span></span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li><code>console.log(&#39;Start&#39;)</code> 和 <code>console.log(&#39;End&#39;)</code> 在主线程上同步执行。</li>
<li><code>Promise.resolve().then()</code> 的回调被放入微任务队列。</li>
<li><code>setTimeout</code> 的回调被放入宏任务队列。</li>
<li>微任务（Promise 的回调）会在宏任务（setTimeout 的回调）之前执行。</li>
</ul>
<h3 id="6-浏览器与-Node-js-的事件循环"><a href="#6-浏览器与-Node-js-的事件循环" class="headerlink" title="6. 浏览器与 Node.js 的事件循环"></a>6. <strong>浏览器与 Node.js 的事件循环</strong></h3><ul>
<li><p><strong>浏览器</strong>：</p>
<ul>
<li><p>事件循环除了处理宏任务和微任务外，还会进行渲染更新。</p>
</li>
<li><p>常见的宏任务包括 <code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code> 等。</p>
</li>
</ul>
</li>
<li><p><strong>Node.js</strong>：</p>
<ul>
<li><p>Node.js 的事件循环有不同的阶段（如 timers、I&#x2F;O callbacks、idle, prepare、poll、check、close callbacks），每个阶段有不同的任务队列。</p>
</li>
<li><p><code>setImmediate</code> 在 Node.js 中用于将回调函数放入事件循环的 <code>check</code> 阶段。</p>
</li>
</ul>
</li>
</ul>
<h2 id="JavaScript-中内存泄漏有哪几种情况？"><a href="#JavaScript-中内存泄漏有哪几种情况？" class="headerlink" title="JavaScript 中内存泄漏有哪几种情况？"></a>JavaScript 中内存泄漏有哪几种情况？</h2><blockquote>
<p>在 JavaScript 中，内存泄漏指的是程序在运行过程中未能释放不再使用的内存，导致内存不断增长，从而影响程序的性能和稳定性。</p>
</blockquote>
<h3 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1. 全局变量"></a>1. <strong>全局变量</strong></h3><p><strong>问题</strong>：意外创建的全局变量不会被垃圾回收器自动清除，因为它们的生命周期与整个程序相同，可能会一直占用内存。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createGlobalVariable</span>(<span class="params"></span>) &#123;</span><br><span class="line">  globalVar = <span class="string">&#x27;This is a global variable&#x27;</span>; <span class="comment">// 缺少 `var`, `let` 或 `const` 关键字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createGlobalVariable</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(globalVar); <span class="comment">// &#x27;This is a global variable&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：始终使用 <code>var</code>、<code>let</code> 或 <code>const</code> 声明变量，避免创建隐式全局变量。</p>
<h3 id="2-闭包导致的内存泄漏"><a href="#2-闭包导致的内存泄漏" class="headerlink" title="2. 闭包导致的内存泄漏"></a>2. <strong>闭包导致的内存泄漏</strong></h3><p><strong>问题</strong>：闭包可以导致函数内部引用外部函数的变量，从而使得这些变量无法被垃圾回收器释放，即使外部函数已经执行完毕。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createClosure</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> largeArray = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>).<span class="title function_">fill</span>(<span class="string">&#x27;data&#x27;</span>); <span class="comment">// 大量数据</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(largeArray[<span class="number">0</span>]);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> closure = <span class="title function_">createClosure</span>();</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：谨慎使用闭包，确保在不再需要时及时释放不再使用的对象。</p>
<h3 id="3-DOM-引用"><a href="#3-DOM-引用" class="headerlink" title="3. DOM 引用"></a>3. <strong>DOM 引用</strong></h3><p><strong>问题</strong>：如果 JavaScript 保持对 DOM 元素的引用，而这些元素已从文档中删除，可能会导致这些元素无法被垃圾回收器释放。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myElement&#x27;</span>);</span><br><span class="line">element.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(element); <span class="comment">// 从 DOM 中移除元素</span></span><br><span class="line"><span class="comment">// 如果 JavaScript 代码中仍持有对 `element` 的引用，可能会导致内存泄漏</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：在移除 DOM 元素时，确保清理所有对该元素的引用，避免造成内存泄漏。</p>
<h3 id="4-定时器和回调"><a href="#4-定时器和回调" class="headerlink" title="4. 定时器和回调"></a>4. <strong>定时器和回调</strong></h3><p><strong>问题</strong>：未清除的定时器（如 <code>setInterval</code>）和回调函数可能会导致内存泄漏，特别是当它们持有对大对象或 DOM 元素的引用时。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intervalId = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当不再需要时没有清除定时器</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：在不再需要定时器时，使用 <code>clearInterval</code> 或 <code>clearTimeout</code> 来停止它们。</p>
<h3 id="5-事件监听器"><a href="#5-事件监听器" class="headerlink" title="5. 事件监听器"></a>5. <strong>事件监听器</strong></h3><p><strong>问题</strong>：添加的事件监听器如果不再需要时没有被移除，可能会导致内存泄漏，因为事件监听器会保持对目标对象的引用。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addEventListener</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myButton&#x27;</span>);</span><br><span class="line">  button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Button clicked&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持续添加事件监听器但未移除</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：在不再需要事件监听器时，使用 <code>removeEventListener</code> 进行移除。</p>
<h3 id="6-计时器回调和长时间运行的操作"><a href="#6-计时器回调和长时间运行的操作" class="headerlink" title="6. 计时器回调和长时间运行的操作"></a>6. <strong>计时器回调和长时间运行的操作</strong></h3><p><strong>问题</strong>：长时间运行的操作（如大数据处理、复杂计算）可能会导致内存泄漏，因为它们可能会持有大量数据或复杂的状态。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">longRunningOperation</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> largeData = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>).<span class="title function_">fill</span>(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">  <span class="comment">// 长时间运行的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">longRunningOperation</span>();</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：优化长时间运行的操作，确保及时清理不再需要的数据。</p>
<h3 id="7-意外的闭包和递归"><a href="#7-意外的闭包和递归" class="headerlink" title="7. 意外的闭包和递归"></a>7. <strong>意外的闭包和递归</strong></h3><p><strong>问题</strong>：不正确的闭包和递归调用可能导致内存泄漏，尤其是在大量数据或复杂结构的情况下。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">recursiveFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> largeData = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1000000</span>).<span class="title function_">fill</span>(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">  <span class="title function_">recursiveFunction</span>(); <span class="comment">// 递归调用可能导致堆栈溢出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">recursiveFunction</span>();</span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：优化递归调用，避免无限递归和过深的递归嵌套。</p>
<h3 id="8-缓存和存储"><a href="#8-缓存和存储" class="headerlink" title="8. 缓存和存储"></a>8. <strong>缓存和存储</strong></h3><p><strong>问题</strong>：某些缓存机制和存储（如全局缓存）可能导致内存泄漏，特别是在缓存未及时清除的情况下。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cacheData</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  cache.<span class="title function_">set</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未清除缓存</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方法</strong>：使用适当的缓存策略，定期清理不再需要的缓存。</p>
<h3 id="总结-32"><a href="#总结-32" class="headerlink" title="总结"></a>总结</h3><p>内存泄漏通常是由于未能及时释放不再使用的内存或对象引用。常见的内存泄漏情况包括全局变量、闭包、DOM 引用、未清除的定时器和事件监听器、长时间运行的操作以及缓存和存储。通过小心管理变量引用、及时清理不再需要的对象和使用现代工具（如内存分析器），可以有效地减少和防止内存泄漏。</p>
<h2 id="JavaScript-的本地存储有哪些方式？"><a href="#JavaScript-的本地存储有哪些方式？" class="headerlink" title="JavaScript 的本地存储有哪些方式？"></a>JavaScript 的本地存储有哪些方式？</h2><blockquote>
<p>在 JavaScript 中，本地存储（Local Storage）是指浏览器提供的一种机制，用于在用户的浏览器中持久化存储数据。</p>
</blockquote>
<h3 id="1-localStorage"><a href="#1-localStorage" class="headerlink" title="1. localStorage"></a>1. <code>localStorage</code></h3><ul>
<li><strong>描述</strong>：<code>localStorage</code> 是一种用于存储键值对的机制，这些键值对在浏览器关闭后仍然保持。数据持久化存储在浏览器中，直到显式删除。</li>
<li><strong>存储大小</strong>：一般在 5MB 左右（具体大小依浏览器而异）。</li>
<li><strong>使用方法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="keyword">const</span> value = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除所有数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>();</span><br></pre></td></tr></table></figure>

<h3 id="2-sessionStorage"><a href="#2-sessionStorage" class="headerlink" title="2. sessionStorage"></a>2. <code>sessionStorage</code></h3><ul>
<li><strong>描述</strong>：<code>sessionStorage</code> 是一种用于存储键值对的机制，这些键值对在浏览器会话（即标签页或窗口）中保持。数据在浏览器标签页或窗口关闭后被清除。</li>
<li><strong>存储大小</strong>：一般在 5MB 左右（具体大小依浏览器而异）。</li>
<li><strong>使用方法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置数据</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据</span></span><br><span class="line"><span class="keyword">const</span> value = <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数据</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除所有数据</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">clear</span>();</span><br></pre></td></tr></table></figure>

<h3 id="3-Cookies"><a href="#3-Cookies" class="headerlink" title="3. Cookies"></a>3. <strong>Cookies</strong></h3><ul>
<li><strong>描述</strong>：Cookies 是一种用于存储小量数据的机制。数据会随每个 HTTP 请求发送到服务器，并且可以在浏览器中持久化存储，直到过期。</li>
<li><strong>存储大小</strong>：每个 cookie 最大约为 4KB，总大小受到浏览器的限制（通常每个域名可存储 20 个左右的 cookies）。</li>
<li><strong>使用方法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 cookie</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;key=value; expires=Thu, 01 Jan 2025 00:00:00 GMT; path=/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 cookie</span></span><br><span class="line"><span class="keyword">const</span> cookies = <span class="variable language_">document</span>.<span class="property">cookie</span>; <span class="comment">// 注意：需要手动解析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 cookie</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">cookie</span> = <span class="string">&quot;key=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-IndexedDB"><a href="#4-IndexedDB" class="headerlink" title="4. IndexedDB"></a>4. <strong>IndexedDB</strong></h3><ul>
<li><strong>描述</strong>：IndexedDB 是一个低级 API，用于在浏览器中存储大量结构化数据，包括文件和二进制数据。它支持事务和索引，提供了更强大的查询和存储能力。</li>
<li><strong>存储大小</strong>：通常没有明确限制，但浏览器可能会对单个域名设置存储配额。</li>
<li><strong>使用方法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开数据库</span></span><br><span class="line"><span class="keyword">const</span> request = indexedDB.<span class="title function_">open</span>(<span class="string">&#x27;myDatabase&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">request.<span class="property">onupgradeneeded</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="comment">// 创建对象存储（表）</span></span><br><span class="line">  db.<span class="title function_">createObjectStore</span>(<span class="string">&#x27;myStore&#x27;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;id&#x27;</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">request.<span class="property">onsuccess</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> db = event.<span class="property">target</span>.<span class="property">result</span>;</span><br><span class="line">  <span class="comment">// 开始事务</span></span><br><span class="line">  <span class="keyword">const</span> transaction = db.<span class="title function_">transaction</span>(<span class="string">&#x27;myStore&#x27;</span>, <span class="string">&#x27;readwrite&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> store = transaction.<span class="title function_">objectStore</span>(<span class="string">&#x27;myStore&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 添加数据</span></span><br><span class="line">  store.<span class="title function_">add</span>(&#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取数据</span></span><br><span class="line">  <span class="keyword">const</span> getRequest = store.<span class="title function_">get</span>(<span class="number">1</span>);</span><br><span class="line">  getRequest.<span class="property">onsuccess</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(getRequest.<span class="property">result</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-WebSQL（不再推荐使用）"><a href="#5-WebSQL（不再推荐使用）" class="headerlink" title="5. WebSQL（不再推荐使用）"></a>5. <strong>WebSQL</strong>（不再推荐使用）</h3><ul>
<li><strong>描述</strong>：WebSQL 是一个过时的 API，用于在浏览器中存储数据，使用 SQL 语法进行查询。已被 IndexedDB 替代，并且在新项目中不推荐使用。</li>
<li><strong>存储大小</strong>：大小依浏览器实现而异。</li>
<li><strong>使用方法</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开数据库</span></span><br><span class="line"><span class="keyword">const</span> db = <span class="title function_">openDatabase</span>(<span class="string">&#x27;myDatabase&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>, <span class="string">&#x27;Test DB&#x27;</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建表并插入数据</span></span><br><span class="line">db.<span class="title function_">transaction</span>(<span class="keyword">function</span>(<span class="params">tx</span>) &#123;</span><br><span class="line">  tx.<span class="title function_">executeSql</span>(<span class="string">&#x27;CREATE TABLE IF NOT EXISTS myTable (id unique, name)&#x27;</span>);</span><br><span class="line">  tx.<span class="title function_">executeSql</span>(<span class="string">&#x27;INSERT INTO myTable (id, name) VALUES (1, &quot;John&quot;)&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询数据</span></span><br><span class="line">db.<span class="title function_">transaction</span>(<span class="keyword">function</span>(<span class="params">tx</span>) &#123;</span><br><span class="line">  tx.<span class="title function_">executeSql</span>(<span class="string">&#x27;SELECT * FROM myTable&#x27;</span>, [], <span class="keyword">function</span>(<span class="params">tx, results</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results.<span class="property">rows</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="总结-33"><a href="#总结-33" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>localStorage</code> 和 <code>sessionStorage</code>：适用于存储较小的数据，<code>localStorage</code> 数据持久化，<code>sessionStorage</code> 数据在会话结束时被清除。</li>
<li><strong>Cookies</strong>：适用于少量数据的持久化存储，但数据会随每个请求发送，存储空间较小。</li>
<li><strong>IndexedDB</strong>：适用于存储大量结构化数据，支持事务和索引。</li>
<li><strong>WebSQL</strong>：过时的 API，建议使用 IndexedDB 替代。</li>
</ul>
<h1 id="第十章-应用"><a href="#第十章-应用" class="headerlink" title="第十章 应用"></a>第十章 应用</h1><h2 id="如何实现大文件上传？"><a href="#如何实现大文件上传？" class="headerlink" title="如何实现大文件上传？"></a>如何实现大文件上传？</h2><h3 id="1-分片上传（Chunked-Upload）"><a href="#1-分片上传（Chunked-Upload）" class="headerlink" title="1. 分片上传（Chunked Upload）"></a>1. <strong>分片上传（Chunked Upload）</strong></h3><blockquote>
<p>分片上传是将大文件拆分成小块（分片），逐个上传这些小块，并在服务器端重组。这种方法可以提高上传稳定性，允许恢复中断的上传，并减少单个请求的负载。</p>
</blockquote>
<p><strong>基本步骤</strong>：</p>
<ol>
<li><strong>拆分文件</strong>：将文件拆分成多个小块。</li>
<li><strong>上传分片</strong>：逐个上传这些小块。</li>
<li><strong>服务器端处理</strong>：在服务器端接收并重组分片，生成最终的完整文件。</li>
<li><strong>处理进度</strong>：监控上传进度并更新用户界面。</li>
</ol>
<p><strong>示例代码</strong>（前端）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uploadFile</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> chunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1MB</span></span><br><span class="line">  <span class="keyword">const</span> totalChunks = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(file.<span class="property">size</span> / chunkSize);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">uploadChunk</span>(<span class="params">chunk, index</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, chunk, file.<span class="property">name</span>);</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&#x27;index&#x27;</span>, index);</span><br><span class="line">    formData.<span class="title function_">append</span>(<span class="string">&#x27;totalChunks&#x27;</span>, totalChunks);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/upload-chunk&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="attr">body</span>: formData</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">uploadNextChunk</span>(<span class="params">index</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= totalChunks) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> start = index * chunkSize;</span><br><span class="line">    <span class="keyword">const</span> end = <span class="title class_">Math</span>.<span class="title function_">min</span>(file.<span class="property">size</span>, start + chunkSize);</span><br><span class="line">    <span class="keyword">const</span> chunk = file.<span class="title function_">slice</span>(start, end);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">uploadChunk</span>(chunk, index)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">uploadNextChunk</span>(index + <span class="number">1</span>))</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Upload failed:&#x27;</span>, error));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">uploadNextChunk</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例代码</strong>（服务器端，Node.js）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/upload-chunk&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; index, totalChunks &#125; = req.<span class="property">body</span>;</span><br><span class="line">  <span class="keyword">const</span> file = req.<span class="property">files</span>.<span class="property">file</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> uploadPath = path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;uploads&#x27;</span>, <span class="string">&#x27;file.part&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> writeStream = fs.<span class="title function_">createWriteStream</span>(uploadPath, &#123; <span class="attr">flags</span>: <span class="string">&#x27;a&#x27;</span> &#125;);</span><br><span class="line">  </span><br><span class="line">  file.<span class="title function_">pipe</span>(writeStream);</span><br><span class="line">  </span><br><span class="line">  writeStream.<span class="title function_">on</span>(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">parseInt</span>(index) + <span class="number">1</span> === <span class="built_in">parseInt</span>(totalChunks)) &#123;</span><br><span class="line">      <span class="comment">// All chunks uploaded, merge chunks</span></span><br><span class="line">      fs.<span class="title function_">renameSync</span>(uploadPath, path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;uploads&#x27;</span>, <span class="string">&#x27;file&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    res.<span class="title function_">sendStatus</span>(<span class="number">200</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="2-使用-FormData-和-XMLHttpRequest"><a href="#2-使用-FormData-和-XMLHttpRequest" class="headerlink" title="2. 使用 FormData 和 XMLHttpRequest"></a>2. <strong>使用</strong> <code>FormData</code> <strong>和</strong> <code>XMLHttpRequest</code></h3><p>使用 <code>FormData</code> 和 <code>XMLHttpRequest</code> 可以支持大文件的上传，同时能够监控上传进度。</p>
<p><strong>示例代码</strong>（前端）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uploadFile</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  <span class="keyword">const</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">  </span><br><span class="line">  formData.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, file);</span><br><span class="line">  </span><br><span class="line">  xhr.<span class="property">upload</span>.<span class="property">onprogress</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">lengthComputable</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> percentComplete = (event.<span class="property">loaded</span> / event.<span class="property">total</span>) * <span class="number">100</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Upload progress: <span class="subst">$&#123;percentComplete&#125;</span>%`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Upload successful!&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Upload failed:&#x27;</span>, xhr.<span class="property">statusText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/upload&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.<span class="title function_">send</span>(formData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-使用-Blob-和-FileReader"><a href="#3-使用-Blob-和-FileReader" class="headerlink" title="3. 使用 Blob 和 FileReader"></a>3. <strong>使用</strong> <code>Blob</code> <strong>和</strong> <code>FileReader</code></h3><p>使用 <code>Blob</code> 和 <code>FileReader</code> 来读取和上传文件的不同部分，以便在上传过程中处理更大的文件。</p>
<p><strong>示例代码</strong>（前端）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uploadFile</span>(<span class="params">file</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line">  </span><br><span class="line">  reader.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/upload&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/octet-stream&#x27;</span>);</span><br><span class="line">    xhr.<span class="title function_">send</span>(reader.<span class="property">result</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  reader.<span class="title function_">readAsArrayBuffer</span>(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-使用-Web-Workers"><a href="#4-使用-Web-Workers" class="headerlink" title="4. 使用 Web Workers"></a>4. <strong>使用 Web Workers</strong></h3><p>Web Workers 可以在后台线程中执行上传操作，防止阻塞主线程，提高用户体验。</p>
<p><strong>示例代码</strong>（前端）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; file, url &#125; = event.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">  </span><br><span class="line">  xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, url, <span class="literal">true</span>);</span><br><span class="line">  xhr.<span class="title function_">send</span>(file);</span><br><span class="line">  </span><br><span class="line">  xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    self.<span class="title function_">postMessage</span>(<span class="string">&#x27;Upload complete&#x27;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;worker.js&#x27;</span>);</span><br><span class="line">worker.<span class="title function_">postMessage</span>(&#123; <span class="attr">file</span>: yourFile, <span class="attr">url</span>: <span class="string">&#x27;/upload&#x27;</span> &#125;);</span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-使用第三方库"><a href="#5-使用第三方库" class="headerlink" title="5. 使用第三方库"></a>5. <strong>使用第三方库</strong></h3><p>许多第三方库和框架可以帮助处理大文件上传，例如：</p>
<ul>
<li><strong>Dropzone</strong>: 提供了拖放上传和进度监控功能。</li>
<li><strong>Fine Uploader</strong>: 支持分片上传、拖放上传等。</li>
<li><strong>Plupload</strong>: 支持多种文件上传方式，包括分片上传。</li>
</ul>
<h3 id="总结-34"><a href="#总结-34" class="headerlink" title="总结"></a>总结</h3><p>实现大文件上传的方法包括分片上传、使用 <code>FormData</code> 和 <code>XMLHttpRequest</code>、使用 <code>Blob</code> 和 <code>FileReader</code>、Web Workers 以及使用第三方库。选择哪种方法取决于具体的需求，例如文件大小、用户体验、兼容性和后端处理能力。</p>
<h2 id="如何实现树形结构列表和扁平列表的互相转换？"><a href="#如何实现树形结构列表和扁平列表的互相转换？" class="headerlink" title="如何实现树形结构列表和扁平列表的互相转换？"></a>如何实现树形结构列表和扁平列表的互相转换？</h2><blockquote>
<p>树形结构列表和扁平列表的互相转换是数据处理中的常见需求，尤其是在处理分类数据或目录结构时。</p>
</blockquote>
<h3 id="1-树形结构转换为扁平列表"><a href="#1-树形结构转换为扁平列表" class="headerlink" title="1. 树形结构转换为扁平列表"></a>1. 树形结构转换为扁平列表</h3><h4 id="树形结构示例"><a href="#树形结构示例" class="headerlink" title="树形结构示例"></a>树形结构示例</h4><p>假设我们有一个树形结构的列表，每个节点包含子节点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Root&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Child 1&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Child 2&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Grandchild 1&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: []</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><p>我们可以使用递归方法将树形结构转换为扁平列表：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenTree</span>(<span class="params">tree</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">recurse</span>(<span class="params">nodes, parentId</span>) &#123;</span><br><span class="line">    nodes.<span class="title function_">forEach</span>(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; children, ...rest &#125; = node;</span><br><span class="line">      result.<span class="title function_">push</span>(&#123; ...rest, parentId &#125;);</span><br><span class="line">      <span class="keyword">if</span> (children &amp;&amp; children.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">recurse</span>(children, node.<span class="property">id</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">recurse</span>(tree, <span class="literal">null</span>); <span class="comment">// Root nodes have no parentId</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flatList = <span class="title function_">flattenTree</span>(tree);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(flatList);</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Root&#x27;</span>, <span class="attr">parentId</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;Child 1&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;Child 2&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="string">&#x27;Grandchild 1&#x27;</span>, <span class="attr">parentId</span>: <span class="number">3</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="2-扁平列表转换为树形结构"><a href="#2-扁平列表转换为树形结构" class="headerlink" title="2. 扁平列表转换为树形结构"></a>2. 扁平列表转换为树形结构</h3><h4 id="扁平列表示例"><a href="#扁平列表示例" class="headerlink" title="扁平列表示例"></a>扁平列表示例</h4><p>假设我们有一个扁平列表，每个项都有一个 <code>parentId</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatList = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;Root&#x27;</span>, <span class="attr">parentId</span>: <span class="literal">null</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;Child 1&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;Child 2&#x27;</span>, <span class="attr">parentId</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="string">&#x27;Grandchild 1&#x27;</span>, <span class="attr">parentId</span>: <span class="number">3</span> &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="转换函数-1"><a href="#转换函数-1" class="headerlink" title="转换函数"></a>转换函数</h4><p>我们可以通过构建一个映射来将扁平列表转换为树形结构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildTree</span>(<span class="params">flatList</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> tree = [];</span><br><span class="line">  </span><br><span class="line">  flatList.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    map[item.<span class="property">id</span>] = &#123; ...item, <span class="attr">children</span>: [] &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  flatList.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">parentId</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      tree.<span class="title function_">push</span>(map[item.<span class="property">id</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (map[item.<span class="property">parentId</span>]) &#123;</span><br><span class="line">        map[item.<span class="property">parentId</span>].<span class="property">children</span>.<span class="title function_">push</span>(map[item.<span class="property">id</span>]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree = <span class="title function_">buildTree</span>(flatList);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(tree);</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Root&#x27;</span>,</span><br><span class="line">    <span class="attr">parentId</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Child 1&#x27;</span>,</span><br><span class="line">        <span class="attr">parentId</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">children</span>: []</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Child 2&#x27;</span>,</span><br><span class="line">        <span class="attr">parentId</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Grandchild 1&#x27;</span>,</span><br><span class="line">            <span class="attr">parentId</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">children</span>: []</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="总结-35"><a href="#总结-35" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>树形结构转换为扁平列表</strong>：递归遍历树形结构，将每个节点及其 <code>parentId</code> 添加到扁平列表中。</li>
<li><strong>扁平列表转换为树形结构</strong>：构建一个映射以便根据 <code>parentId</code> 组织节点，然后形成树形结构。</li>
</ul>
<h2 id="什么是单点登录？"><a href="#什么是单点登录？" class="headerlink" title="什么是单点登录？"></a>什么是单点登录？</h2><blockquote>
<p>单点登录（Single Sign-On, SSO）是一种认证过程，通过这种方式，用户只需要登录一次即可访问多个应用程序或系统，而无需对每个系统或应用程序重复登录。它简化了用户的认证过程，并提高了用户体验。</p>
</blockquote>
<h3 id="单点登录的基本概念"><a href="#单点登录的基本概念" class="headerlink" title="单点登录的基本概念"></a>单点登录的基本概念</h3><ol>
<li><strong>用户登录</strong>：用户在单点登录系统中输入用户名和密码进行认证。</li>
<li><strong>生成令牌</strong>：认证成功后，单点登录系统生成一个认证令牌（如令牌、票据、或会话ID），并将其传递给用户。</li>
<li><strong>访问应用</strong>：用户访问其他需要认证的应用程序时，单点登录系统会自动提供认证令牌。</li>
<li><strong>验证令牌</strong>：其他应用程序验证用户的认证令牌，以确保用户已经通过认证，从而允许用户访问其服务。</li>
</ol>
<h3 id="单点登录的工作流程"><a href="#单点登录的工作流程" class="headerlink" title="单点登录的工作流程"></a>单点登录的工作流程</h3><ol>
<li><p><strong>用户登录到单点登录服务</strong>：</p>
<ul>
<li>用户向单点登录服务发送登录请求。</li>
<li>单点登录服务验证用户的凭据（如用户名和密码）。</li>
</ul>
</li>
<li><p><strong>单点登录服务生成和返回认证令牌</strong>：</p>
<ul>
<li>登录成功后，单点登录服务生成一个认证令牌并返回给用户。</li>
</ul>
</li>
<li><p><strong>用户访问其他应用程序</strong>：</p>
<ul>
<li>用户访问其他应用程序（这些应用程序已集成单点登录服务）。</li>
<li>用户的浏览器将认证令牌附加到请求中，或通过其他方式传递认证信息。</li>
</ul>
</li>
<li><p><strong>应用程序验证认证令牌</strong>：</p>
<ul>
<li>应用程序验证认证令牌的有效性。</li>
<li>验证成功后，用户可以访问该应用程序的资源和功能。</li>
</ul>
</li>
<li><p><strong>用户注销</strong>：</p>
<ul>
<li>用户可以选择注销，单点登录服务会撤销令牌，并使所有相关应用程序的会话失效。</li>
</ul>
</li>
</ol>
<h3 id="单点登录的优点"><a href="#单点登录的优点" class="headerlink" title="单点登录的优点"></a>单点登录的优点</h3><ul>
<li><strong>简化用户体验</strong>：用户只需一次登录即可访问多个应用程序，无需重复输入凭据。</li>
<li><strong>减少密码疲劳</strong>：减少了用户记住多个密码的需要。</li>
<li><strong>集中管理</strong>：便于集中管理用户认证和授权。</li>
<li><strong>提高安全性</strong>：可以集中处理安全策略，例如多因素认证（MFA），并减少密码暴露的机会。</li>
</ul>
<h3 id="单点登录的缺点"><a href="#单点登录的缺点" class="headerlink" title="单点登录的缺点"></a>单点登录的缺点</h3><ul>
<li><strong>单点故障</strong>：如果单点登录服务出现故障，所有依赖该服务的应用程序也可能受到影响。</li>
<li><strong>复杂的实现</strong>：集成和配置可能较为复杂，尤其是在处理不同系统和协议时。</li>
<li><strong>安全风险</strong>：一个被攻破的账号可能会影响所有集成的系统，因此需要确保单点登录服务的安全性。</li>
</ul>
<h3 id="实现单点登录的常见协议和技术"><a href="#实现单点登录的常见协议和技术" class="headerlink" title="实现单点登录的常见协议和技术"></a>实现单点登录的常见协议和技术</h3><ol>
<li><strong>OAuth 2.0</strong>：一种授权框架，允许用户授权第三方应用程序访问其资源。常用于访问令牌的传递。</li>
<li><strong>OpenID Connect</strong>：基于 OAuth 2.0 的身份层协议，提供认证功能，允许应用程序验证用户身份。</li>
<li><strong>SAML (Security Assertion Markup Language)</strong> ：基于 XML 的协议，主要用于 Web 单点登录。它通过 XML 断言传递认证信息。</li>
<li><strong>Kerberos</strong>：一种网络认证协议，使用票据来验证用户身份，主要用于内部网络环境。</li>
</ol>
<h3 id="总结-36"><a href="#总结-36" class="headerlink" title="总结"></a>总结</h3><p>单点登录（SSO）是为了简化用户认证过程而设计的一种机制，使用户在登录一次后能够访问多个系统或应用程序。它提高了用户体验，并有助于集中管理认证和授权。实现 SSO 的方法有多种，常用的协议包括 OAuth 2.0、OpenID Connect 和 SAML。尽管 SSO 提供了许多便利，但也需要注意其潜在的安全风险和实施复杂性。</p>
<h2 id="Web-常见的攻击方式有哪些？"><a href="#Web-常见的攻击方式有哪些？" class="headerlink" title="Web 常见的攻击方式有哪些？"></a>Web 常见的攻击方式有哪些？</h2><h3 id="1-SQL-注入（SQL-Injection）"><a href="#1-SQL-注入（SQL-Injection）" class="headerlink" title="1. SQL 注入（SQL Injection）"></a>1. <strong>SQL 注入（SQL Injection）</strong></h3><ul>
<li><strong>描述</strong>：攻击者通过在 Web 表单或 URL 中插入恶意 SQL 代码来操控数据库查询，从而获取、修改或删除数据库中的数据。</li>
<li><strong>防护措施</strong>：使用参数化查询或预编译语句，避免将用户输入直接嵌入 SQL 语句中。</li>
</ul>
<h3 id="2-跨站脚本（XSS-Cross-Site-Scripting）"><a href="#2-跨站脚本（XSS-Cross-Site-Scripting）" class="headerlink" title="2. 跨站脚本（XSS, Cross-Site Scripting）"></a>2. <strong>跨站脚本（XSS, Cross-Site Scripting）</strong></h3><ul>
<li><strong>描述</strong>：攻击者在网页中注入恶意脚本，这些脚本会在其他用户的浏览器中执行。XSS 攻击可以窃取用户的 cookie、会话信息或执行其他恶意操作。</li>
<li><strong>防护措施</strong>：对用户输入进行严格的验证和过滤，使用安全的编码方法，应用内容安全策略（CSP）。</li>
</ul>
<h3 id="3-跨站请求伪造（CSRF-Cross-Site-Request-Forgery）"><a href="#3-跨站请求伪造（CSRF-Cross-Site-Request-Forgery）" class="headerlink" title="3. 跨站请求伪造（CSRF, Cross-Site Request Forgery）"></a>3. <strong>跨站请求伪造（CSRF, Cross-Site Request Forgery）</strong></h3><ul>
<li><strong>描述</strong>：攻击者诱使用户在已认证的会话中执行不期望的操作，例如发送未授权的请求。</li>
<li><strong>防护措施</strong>：使用 CSRF 令牌来验证请求的合法性，确保每个状态改变请求都有唯一的令牌。</li>
</ul>
<h3 id="4-会话劫持（Session-Hijacking）"><a href="#4-会话劫持（Session-Hijacking）" class="headerlink" title="4. 会话劫持（Session Hijacking）"></a>4. <strong>会话劫持（Session Hijacking）</strong></h3><ul>
<li><strong>描述</strong>：攻击者窃取用户的会话 ID，从而获得对用户会话的控制权。</li>
<li><strong>防护措施</strong>：使用安全的 cookie 属性（如 HttpOnly 和 Secure），定期更新会话 ID，使用 HTTPS 来保护数据传输。</li>
</ul>
<h3 id="5-会话固定（Session-Fixation）"><a href="#5-会话固定（Session-Fixation）" class="headerlink" title="5. 会话固定（Session Fixation）"></a>5. <strong>会话固定（Session Fixation）</strong></h3><ul>
<li><strong>描述</strong>：攻击者在用户认证前设置一个已知的会话 ID，用户认证后，攻击者可以利用这个会话 ID 获得用户的会话权限。</li>
<li><strong>防护措施</strong>：在用户登录后更新会话 ID，确保会话 ID 在认证过程中不会被固定。</li>
</ul>
<h3 id="6-目录遍历（Directory-Traversal）"><a href="#6-目录遍历（Directory-Traversal）" class="headerlink" title="6. 目录遍历（Directory Traversal）"></a>6. <strong>目录遍历（Directory Traversal）</strong></h3><ul>
<li><strong>描述</strong>：攻击者通过访问不应公开的文件或目录，试图访问服务器文件系统上的敏感文件。</li>
<li><strong>防护措施</strong>：对用户输入进行严格验证，限制文件访问权限，确保 Web 应用程序不允许访问不应暴露的文件和目录。</li>
</ul>
<h3 id="7-命令注入（Command-Injection）"><a href="#7-命令注入（Command-Injection）" class="headerlink" title="7. 命令注入（Command Injection）"></a>7. <strong>命令注入（Command Injection）</strong></h3><ul>
<li><strong>描述</strong>：攻击者通过在应用程序中注入恶意命令，执行操作系统命令，从而获得系统权限或访问敏感信息。</li>
<li><strong>防护措施</strong>：对用户输入进行严格验证，避免直接将输入嵌入系统命令中，使用安全的系统调用方法。</li>
</ul>
<h3 id="8-文件上传漏洞（File-Upload-Vulnerability）"><a href="#8-文件上传漏洞（File-Upload-Vulnerability）" class="headerlink" title="8. 文件上传漏洞（File Upload Vulnerability）"></a>8. <strong>文件上传漏洞（File Upload Vulnerability）</strong></h3><ul>
<li><strong>描述</strong>：攻击者上传恶意文件（如脚本文件）到服务器，通过这些文件执行恶意操作。</li>
<li><strong>防护措施</strong>：对上传的文件进行严格验证，限制文件类型和大小，存储文件在隔离的目录中并设置适当的权限。</li>
</ul>
<h3 id="9-服务器端请求伪造（SSRF-Server-Side-Request-Forgery）"><a href="#9-服务器端请求伪造（SSRF-Server-Side-Request-Forgery）" class="headerlink" title="9. 服务器端请求伪造（SSRF, Server-Side Request Forgery）"></a>9. <strong>服务器端请求伪造（SSRF, Server-Side Request Forgery）</strong></h3><ul>
<li><strong>描述</strong>：攻击者诱使服务器发起未经授权的请求，可能访问内部服务或外部资源。</li>
<li><strong>防护措施</strong>：限制服务器发出的请求的目的地，验证和过滤用户输入，避免直接将用户输入作为请求目标。</li>
</ul>
<h3 id="10-中间人攻击（MITM-Man-In-The-Middle）"><a href="#10-中间人攻击（MITM-Man-In-The-Middle）" class="headerlink" title="10. 中间人攻击（MITM, Man-In-The-Middle）"></a>10. <strong>中间人攻击（MITM, Man-In-The-Middle）</strong></h3><ul>
<li><strong>描述</strong>：攻击者在用户和服务器之间拦截和篡改通信，窃取或修改数据。</li>
<li><strong>防护措施</strong>：使用 HTTPS 加密通信，确保数据传输的安全性，使用证书验证和密钥交换机制。</li>
</ul>
<h3 id="11-暴力破解（Brute-Force-Attack）"><a href="#11-暴力破解（Brute-Force-Attack）" class="headerlink" title="11. 暴力破解（Brute Force Attack）"></a>11. <strong>暴力破解（Brute Force Attack）</strong></h3><ul>
<li><strong>描述</strong>：攻击者通过尝试所有可能的密码或密钥组合，强行破解用户账户或加密数据。</li>
<li><strong>防护措施</strong>：实施账户锁定策略、强密码策略，使用 CAPTCHA 防止自动化攻击。</li>
</ul>
<h3 id="12-拒绝服务攻击（DoS-DDoS-Denial-of-Service-Distributed-Denial-of-Service）"><a href="#12-拒绝服务攻击（DoS-DDoS-Denial-of-Service-Distributed-Denial-of-Service）" class="headerlink" title="12. 拒绝服务攻击（DoS&#x2F;DDoS, Denial of Service&#x2F;Distributed Denial of Service）"></a>12. <strong>拒绝服务攻击（DoS&#x2F;DDoS, Denial of Service&#x2F;Distributed Denial of Service）</strong></h3><ul>
<li><strong>描述</strong>：攻击者通过大量无效请求或流量使服务器无法处理合法请求，从而导致服务中断。</li>
<li><strong>防护措施</strong>：使用流量过滤、负载均衡和防火墙，监控和限制异常流量。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.huitaiyang.top">灰太羊</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.huitaiyang.top/2024/09/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4%EF%BC%9AJavaScript(2%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87)/">https://blog.huitaiyang.top/2024/09/19/前端面试突破：JavaScript(2万字长文)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.huitaiyang.top" target="_blank">灰太羊的羊村</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202409191948011.png" data-sites="facebook,twitter,wechat,qq,weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>请我喝杯咖啡吧!</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408141707444%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408141707444%E5%BE%AE%E4%BF%A1%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408141705225%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" target="_blank"><img class="post-qr-code-img" src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408141705225%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%B6%E6%AC%BE%E7%A0%81.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/08/31/JavaScript%E7%9A%84FunctionalProgramming/" title="JavaScript函数式编程"><img class="cover" src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408311908227.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript函数式编程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/08/14/1/" title="JavaScript运算符"><img class="cover" src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408141806986.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-14</div><div class="title">JavaScript运算符</div></div></a></div><div><a href="/2024/08/30/JS%E8%A3%85%E9%A5%B0%E5%99%A8Decorator/" title="Decorator——JS装饰器"><img class="cover" src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408302131697.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-30</div><div class="title">Decorator——JS装饰器</div></div></a></div><div><a href="/2024/08/15/JavaScript%E4%B8%AD%E7%9A%84Symbol%E7%B1%BB%E5%9E%8B/" title="JavaScript中的Symbol类型"><img class="cover" src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408151148316.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-15</div><div class="title">JavaScript中的Symbol类型</div></div></a></div><div><a href="/2024/08/25/JavaScript%E4%B8%AD%E7%9A%84new%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%A9%B6%E7%AB%9F%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/" title="JavaScript中的new操作符究竟干了什么？"><img class="cover" src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408252008926.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-25</div><div class="title">JavaScript中的new操作符究竟干了什么？</div></div></a></div><div><a href="/2024/08/23/JavaScript8%E7%A7%8Dinherit%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%87%A0%E7%A7%8D/" title="JavaScript继承的8种方式，你知道几种？"><img class="cover" src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408232029028.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-23</div><div class="title">JavaScript继承的8种方式，你知道几种？</div></div></a></div><div><a href="/2024/08/25/JavaScript%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/" title="JavaScript中的this指向问题"><img class="cover" src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408252000110.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-25</div><div class="title">JavaScript中的this指向问题</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408141635343.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灰太羊</div><div class="author-info__description">灰太羊的个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/DRXDRXDRX"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/DRXDRXDRX" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3217726912@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="https://juejin.cn/user/3010896565120045" target="_blank" title="掘金"><i class="fa-solid fa-layer-group" style="color: #1E80FF;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到灰太羊的羊村，和我一起学习进步吧!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-JavaScript-%E5%8F%98%E9%87%8F"><span class="toc-text">第一章 JavaScript 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#var%E3%80%81let%E3%80%81const-%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-text">var、let、const 的差异？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-text">谈谈作用域？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%9F"><span class="toc-text">什么是变量提升？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%A1%A8%E7%8E%B0"><span class="toc-text">具体表现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-JavaScript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">第二章 JavaScript 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">JavaScript 数据类型有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%EF%BC%88Primitive-Types%EF%BC%89"><span class="toc-text">1. 原始类型（Primitive Types）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%88Reference-Types%EF%BC%89"><span class="toc-text">2. 引用类型（Reference Types）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">原始数据类型和引用数据类型的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">1. 存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B5%8B%E5%80%BC%E6%96%B9%E5%BC%8F"><span class="toc-text">2. 赋值方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AF%94%E8%BE%83%E6%96%B9%E5%BC%8F"><span class="toc-text">3. 比较方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-0-1-0-2-0-3-%EF%BC%9F"><span class="toc-text">为什么 0.1 + 0.2 !&#x3D;&#x3D; 0.3 ？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0"><span class="toc-text">问题原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">解决方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-undefined-%E5%92%8C-null-%EF%BC%9F"><span class="toc-text">谈谈 undefined 和 null ？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined"><span class="toc-text">undefined</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-text">null</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-text">主要区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-null-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">typeof null 的结果是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90"><span class="toc-text">原因分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%A6%82%E4%BD%95%E5%81%9A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-text">JavaScript 如何做类型转换？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-text">1. 隐式类型转换（自动转换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E6%89%8B%E5%8A%A8%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-text">2. 显式类型转换（手动转换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-text">3. 特殊情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%81-%E5%92%8C-Object-is-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">&#x3D;&#x3D;、 &#x3D;&#x3D;&#x3D; 和 Object.is() 的区别是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EF%BC%88%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89"><span class="toc-text">1. &#x3D;&#x3D; （相等操作符）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EF%BC%88%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89"><span class="toc-text">2. &#x3D;&#x3D;&#x3D; （严格相等操作符）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Object-is"><span class="toc-text">3. Object.is()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">JavaScript 判断数据类型有哪些方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-typeof-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">1. typeof 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-instanceof-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">2. instanceof 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Object-prototype-toString-call-%E6%96%B9%E6%B3%95"><span class="toc-text">3. Object.prototype.toString.call() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Array-isArray-%E6%96%B9%E6%B3%95"><span class="toc-text">4. Array.isArray() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Number-isNaN-%E6%96%B9%E6%B3%95"><span class="toc-text">5. Number.isNaN() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-typeof-%E4%B8%8E-constructor"><span class="toc-text">6. typeof 与 constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-isFinite-%E5%87%BD%E6%95%B0"><span class="toc-text">7. isFinite() 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-isInteger-%E6%96%B9%E6%B3%95"><span class="toc-text">8. isInteger() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">第三章 操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%81-%E5%92%8C-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">||&#x3D; 、&amp;&amp;&#x3D; 和 ??&#x3D; 是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%EF%BC%88%E9%80%BB%E8%BE%91%E6%88%96%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89"><span class="toc-text">1. ||&#x3D; （逻辑或赋值操作符）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EF%BC%88%E9%80%BB%E8%BE%91%E4%B8%8E%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89"><span class="toc-text">2. &amp;&amp;&#x3D; （逻辑与赋值操作符）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%EF%BC%88%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6%EF%BC%89"><span class="toc-text">3. ??&#x3D; （空值合并赋值操作符）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">可选链 ?. 有什么用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E9%80%94%E5%92%8C%E8%A1%8C%E4%B8%BA"><span class="toc-text">用途和行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%92%8C%E7%A4%BA%E4%BE%8B"><span class="toc-text">语法和示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AF%B9%E8%B1%A1"><span class="toc-text">第四章 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">JavaScript 创建对象有哪些方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E9%9D%A2%E9%87%8F%E6%96%B9%E5%BC%8F"><span class="toc-text">1. 字面量方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">2. 构造函数方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Object-create-%E6%96%B9%E6%B3%95"><span class="toc-text">3. Object.create() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-class-%E8%AF%AD%E6%B3%95%EF%BC%88ES6-%EF%BC%89"><span class="toc-text">4. class 语法（ES6+）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Object-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">5. Object 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F"><span class="toc-text">如何理解继承和原型链？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-text">原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF"><span class="toc-text">构造函数和原型继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-11"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">继承有哪几种方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-text">1. 构造函数继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-text">2. 原型链继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-text">3. 组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AF%84%E7%94%9F%E7%BB%A7%E6%89%BF"><span class="toc-text">4. 寄生继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-ES6-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-text">5. ES6 类继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-12"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%B1%BB%EF%BC%9F"><span class="toc-text">如何判断一个对象属于某个类？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1. instanceof 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-constructor-%E5%B1%9E%E6%80%A7"><span class="toc-text">2. constructor 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Object-getPrototypeOf-%E6%96%B9%E6%B3%95"><span class="toc-text">3. Object.getPrototypeOf 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Symbol-hasInstance-%E6%96%B9%E6%B3%95"><span class="toc-text">4. Symbol.hasInstance 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-13"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map-%E5%92%8C-WeakMap-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">Map 和 WeakMap 有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%94%AE%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 键的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-text">2. 垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BF%AD%E4%BB%A3"><span class="toc-text">3. 迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4. 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-14"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-text">如何实现深拷贝和浅拷贝？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-text">浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-text">深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-15"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="toc-text">第五章 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F"><span class="toc-text">什么是闭包？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-16"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this-%E7%9A%84%E6%8C%87%E5%90%91%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">this 的指向有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">1. 全局上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">2. 函数上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">3. 对象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">4. 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-call-%E5%92%8C-apply-%E6%96%B9%E6%B3%95"><span class="toc-text">5. call 和 apply 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-bind-%E6%96%B9%E6%B3%95"><span class="toc-text">6. bind 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-class-%E6%96%B9%E6%B3%95"><span class="toc-text">7. class 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-17"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E5%8C%96%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">类数组的转化方式有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-Array-from"><span class="toc-text">1. 使用 Array.from()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Spread-Operator%EF%BC%89"><span class="toc-text">2. 使用扩展运算符（Spread Operator）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-Array-prototype-slice-call"><span class="toc-text">3. 使用 Array.prototype.slice.call()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-Array-prototype-slice-apply"><span class="toc-text">4. 使用 Array.prototype.slice.apply()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8-Array-prototype-concat"><span class="toc-text">5. 使用 Array.prototype.concat()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-18"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%EF%BC%9Acall-%E3%80%81apply-%E3%80%81bind-%EF%BC%9F"><span class="toc-text">如何模拟实现函数方法：call()、apply()、bind()？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Function-prototype-call"><span class="toc-text">1. Function.prototype.call()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-text">模拟实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Function-prototype-apply"><span class="toc-text">2. Function.prototype.apply()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">模拟实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Function-prototype-bind"><span class="toc-text">3. Function.prototype.bind()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">模拟实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-19"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88IIFE%EF%BC%89%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">立即调用函数表达式（IIFE）有什么特点？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%87%AA%E6%89%A7%E8%A1%8C"><span class="toc-text">1. 自执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">2. 创建私有作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%81%BF%E5%85%8D%E5%85%A8%E5%B1%80%E6%B1%A1%E6%9F%93"><span class="toc-text">3. 避免全局污染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">4. 使用函数表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%94%AF%E6%8C%81%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">5. 支持参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-20"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">箭头函数有什么特点？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9B%B4%E7%AE%80%E6%B4%81%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">1. 更简洁的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%8D%E7%BB%91%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84-this"><span class="toc-text">2. 不绑定自己的 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B2%A1%E6%9C%89-arguments-%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. 没有 arguments 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BD%9C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">4. 不能用作构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-text">5. 简单的单行函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-this-%E7%BB%91%E5%AE%9A%E7%9A%84%E9%9D%99%E6%80%81%E6%80%A7"><span class="toc-text">6. this 绑定的静态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%B8%8D%E5%85%B7%E6%9C%89-prototype-%E5%B1%9E%E6%80%A7"><span class="toc-text">7. 不具有 prototype 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-21"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%EF%BC%9F"><span class="toc-text">如何实现防抖和节流？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%98%B2%E6%8A%96%EF%BC%88Debounce%EF%BC%89"><span class="toc-text">1. 防抖（Debounce）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%8A%82%E6%B5%81%EF%BC%88Throttle%EF%BC%89"><span class="toc-text">2. 节流（Throttle）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-22"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-Promise-Async-await-Generators"><span class="toc-text">第六章 Promise &amp; Async&#x2F;await &amp; Generators</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-Promise%EF%BC%9F"><span class="toc-text">如何模拟实现 Promise？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-text">核心功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">模拟实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%8B-ES6-%E4%B8%AD%E7%9A%84-Iterator-%E5%92%8C-Iterable"><span class="toc-text">简单介绍下 ES6 中的 Iterator 和 Iterable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Iterable%EF%BC%88%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-text">1. Iterable（可迭代对象）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">常见的可迭代对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%95%B0%E7%BB%84%E6%98%AF%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">示例：数组是可迭代对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Iterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89"><span class="toc-text">2. Iterator（迭代器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">如何使用迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. 自定义可迭代对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-23"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%88Generator%EF%BC%89%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">谈谈对生成器（Generator）的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">生成器的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">生成器函数的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-text">生成器的核心概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">生成器的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-async-await"><span class="toc-text">介绍一下 async&#x2F;await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-async-%E5%92%8C-await-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1. async 和 await 的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-async-%E5%92%8C-await-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">2. async 和 await 的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">简单示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-async-await-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-text">3. async&#x2F;await 的核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-async-await-%E4%B8%8E-Promise-%E5%AF%B9%E6%AF%94"><span class="toc-text">4. async&#x2F;await 与 Promise 对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">5. 注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-24"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%A2%E7%BB%BF%E7%81%AF%E6%95%88%E6%9E%9C%EF%BC%9F"><span class="toc-text">如何实现红绿灯效果？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8-setTimeout-%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">1. 使用 setTimeout 和回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-Promise-%E5%AE%9E%E7%8E%B0"><span class="toc-text">2. 使用 Promise 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-async-await-%E5%AE%9E%E7%8E%B0"><span class="toc-text">3. 使用 async&#x2F;await 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-Generator-%E5%AE%9E%E7%8E%B0"><span class="toc-text">4. 使用 Generator 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8-setInterval-%E5%AE%9E%E7%8E%B0"><span class="toc-text">5. 使用 setInterval 实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-25"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%A8%A1%E5%9D%97%EF%BC%88Modules%EF%BC%89"><span class="toc-text">第七章 模块（Modules）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-text">谈谈模块化的发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%A9%E6%9C%9F%E6%B2%A1%E6%9C%89%E6%A8%A1%E5%9D%97%E5%8C%96%E6%94%AF%E6%8C%81"><span class="toc-text">1. 早期没有模块化支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-IIFE%EF%BC%88%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%89%E4%B8%8E%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%A8%A1%E5%BC%8F"><span class="toc-text">2. IIFE（立即调用函数表达式）与命名空间模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-CommonJS-%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">3. CommonJS 模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-AMD%EF%BC%88Asynchronous-Module-Definition%EF%BC%89"><span class="toc-text">4. AMD（Asynchronous Module Definition）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-UMD%EF%BC%88Universal-Module-Definition%EF%BC%89"><span class="toc-text">5. UMD（Universal Module Definition）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-ES6-%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88ES-Module%EF%BC%89"><span class="toc-text">6. ES6 模块化（ES Module）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%8E%B0%E4%BB%A3%E6%A8%A1%E5%9D%97%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7"><span class="toc-text">7. 现代模块打包工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ESM-in-Node-js"><span class="toc-text">8. ESM in Node.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-26"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-Proxy-Reflection"><span class="toc-text">第八章 Proxy &amp; Reflection</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-Object-defineProperty-%E4%B8%8E-Proxy-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">谈谈 Object.defineProperty 与 Proxy 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8A%9F%E8%83%BD%E8%8C%83%E5%9B%B4"><span class="toc-text">1. 功能范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2. 适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. 操作的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%A7%E8%83%BD"><span class="toc-text">4. 性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%94%AF%E6%8C%81%E6%80%A7"><span class="toc-text">5. 支持性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-27"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflect-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-text">Reflect 有什么用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E6%8F%90%E4%BE%9B%E5%87%BD%E6%95%B0%E5%8C%96%E7%9A%84%E6%A0%87%E5%87%86%E6%8E%A5%E5%8F%A3"><span class="toc-text">1. 为对象操作提供函数化的标准接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%8E-Proxy-%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%8F%90%E4%BE%9B%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA"><span class="toc-text">2. 与 Proxy 配合使用，提供默认行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BF%94%E5%9B%9E%E6%93%8D%E4%BD%9C%E6%88%90%E5%8A%9F%E4%B8%8E%E5%90%A6%E7%9A%84%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-text">3. 返回操作成功与否的布尔值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9B%BF%E4%BB%A3%E4%B8%80%E4%BA%9B%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">4. 替代一些不推荐直接使用的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-text">5. 简化函数调用和构造函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%81%BF%E5%85%8D%E6%84%8F%E5%A4%96%E8%A1%8C%E4%B8%BA%E6%88%96%E9%94%99%E8%AF%AF"><span class="toc-text">6. 避免意外行为或错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-Reflect-%E6%96%B9%E6%B3%95"><span class="toc-text">常用的 Reflect 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-28"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-JavaScript-%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="toc-text">第九章 JavaScript 运行时</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-text">谈谈对执行上下文的理解？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 执行上下文的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">2. 执行上下文的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">3. 执行上下文的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-text">4. 作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-this-%E7%BB%91%E5%AE%9A"><span class="toc-text">5. this 绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88"><span class="toc-text">6. 执行上下文栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E9%97%AD%E5%8C%85"><span class="toc-text">7. 执行上下文与闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-29"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-text">简单介绍一下垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-text">1. 垃圾回收的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">2. 标记-清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-text">3. 引用计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86"><span class="toc-text">4. 分代收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E5%92%8C%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%BB%93%E5%90%88"><span class="toc-text">5. 标记-清除和分代收集结合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E8%A7%A6%E5%8F%91"><span class="toc-text">6. 垃圾回收的触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BC%98%E5%8C%96%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="toc-text">7. 优化内存使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-30"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%84%9A%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%98%E6%98%AF-Node-%E7%8E%AF%E5%A2%83%E4%B8%AD%EF%BC%9F"><span class="toc-text">如何判断当前脚本运行在浏览器还是 Node 环境中？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A3%80%E6%9F%A5%E5%85%A8%E5%B1%80%E5%AF%B9%E8%B1%A1"><span class="toc-text">1. 检查全局对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A3%80%E6%9F%A5%E7%8E%AF%E5%A2%83%E7%89%B9%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">2. 检查环境特定的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A3%80%E6%9F%A5%E7%8E%AF%E5%A2%83%E7%89%B9%E5%AE%9A%E7%9A%84%E5%8A%9F%E8%83%BD%E6%88%96%E6%A8%A1%E5%9D%97"><span class="toc-text">3. 检查环境特定的功能或模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-typeof-%E6%A3%80%E6%9F%A5%E7%8E%AF%E5%A2%83%E7%89%B9%E5%AE%9A%E7%9A%84%E6%A8%A1%E5%9D%97%E6%88%96%E5%AF%B9%E8%B1%A1"><span class="toc-text">4. 使用 typeof 检查环境特定的模块或对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%80%A7"><span class="toc-text">5. 使用模块系统特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-31"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">JavaScript 事件循环是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JavaScript-%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">1. JavaScript 单线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8C%E6%A0%88%EF%BC%88Call-Stack%EF%BC%89"><span class="toc-text">2. 执行栈（Call Stack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%EF%BC%88Task-Queue%EF%BC%89"><span class="toc-text">3. 任务队列（Task Queue）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BE%AE%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%EF%BC%88Microtask-Queue%EF%BC%89"><span class="toc-text">4. 微任务队列（Microtask Queue）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">5. 事件循环的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E-Node-js-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">6. 浏览器与 Node.js 的事件循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E4%B8%AD%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-text">JavaScript 中内存泄漏有哪几种情况？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">1. 全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%97%AD%E5%8C%85%E5%AF%BC%E8%87%B4%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-text">2. 闭包导致的内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-DOM-%E5%BC%95%E7%94%A8"><span class="toc-text">3. DOM 引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%9B%9E%E8%B0%83"><span class="toc-text">4. 定时器和回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-text">5. 事件监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AE%A1%E6%97%B6%E5%99%A8%E5%9B%9E%E8%B0%83%E5%92%8C%E9%95%BF%E6%97%B6%E9%97%B4%E8%BF%90%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">6. 计时器回调和长时间运行的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%84%8F%E5%A4%96%E7%9A%84%E9%97%AD%E5%8C%85%E5%92%8C%E9%80%92%E5%BD%92"><span class="toc-text">7. 意外的闭包和递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%BC%93%E5%AD%98%E5%92%8C%E5%AD%98%E5%82%A8"><span class="toc-text">8. 缓存和存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-32"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">JavaScript 的本地存储有哪些方式？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-localStorage"><span class="toc-text">1. localStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-sessionStorage"><span class="toc-text">2. sessionStorage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Cookies"><span class="toc-text">3. Cookies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-IndexedDB"><span class="toc-text">4. IndexedDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-WebSQL%EF%BC%88%E4%B8%8D%E5%86%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-text">5. WebSQL（不再推荐使用）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-33"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%BA%94%E7%94%A8"><span class="toc-text">第十章 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%EF%BC%9F"><span class="toc-text">如何实现大文件上传？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%86%E7%89%87%E4%B8%8A%E4%BC%A0%EF%BC%88Chunked-Upload%EF%BC%89"><span class="toc-text">1. 分片上传（Chunked Upload）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-FormData-%E5%92%8C-XMLHttpRequest"><span class="toc-text">2. 使用 FormData 和 XMLHttpRequest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-Blob-%E5%92%8C-FileReader"><span class="toc-text">3. 使用 Blob 和 FileReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-Web-Workers"><span class="toc-text">4. 使用 Web Workers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93"><span class="toc-text">5. 使用第三方库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-34"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E5%88%97%E8%A1%A8%E5%92%8C%E6%89%81%E5%B9%B3%E5%88%97%E8%A1%A8%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-text">如何实现树形结构列表和扁平列表的互相转换？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%89%81%E5%B9%B3%E5%88%97%E8%A1%A8"><span class="toc-text">1. 树形结构转换为扁平列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B"><span class="toc-text">树形结构示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-text">转换函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%81%E5%B9%B3%E5%88%97%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84"><span class="toc-text">2. 扁平列表转换为树形结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%81%E5%B9%B3%E5%88%97%E8%A1%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">扁平列表示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0-1"><span class="toc-text">转换函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-35"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%EF%BC%9F"><span class="toc-text">什么是单点登录？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">单点登录的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">单点登录的工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">单点登录的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-text">单点登录的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E5%92%8C%E6%8A%80%E6%9C%AF"><span class="toc-text">实现单点登录的常见协议和技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-36"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">Web 常见的攻击方式有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SQL-%E6%B3%A8%E5%85%A5%EF%BC%88SQL-Injection%EF%BC%89"><span class="toc-text">1. SQL 注入（SQL Injection）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%EF%BC%88XSS-Cross-Site-Scripting%EF%BC%89"><span class="toc-text">2. 跨站脚本（XSS, Cross-Site Scripting）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88CSRF-Cross-Site-Request-Forgery%EF%BC%89"><span class="toc-text">3. 跨站请求伪造（CSRF, Cross-Site Request Forgery）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BC%9A%E8%AF%9D%E5%8A%AB%E6%8C%81%EF%BC%88Session-Hijacking%EF%BC%89"><span class="toc-text">4. 会话劫持（Session Hijacking）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BC%9A%E8%AF%9D%E5%9B%BA%E5%AE%9A%EF%BC%88Session-Fixation%EF%BC%89"><span class="toc-text">5. 会话固定（Session Fixation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%EF%BC%88Directory-Traversal%EF%BC%89"><span class="toc-text">6. 目录遍历（Directory Traversal）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5%EF%BC%88Command-Injection%EF%BC%89"><span class="toc-text">7. 命令注入（Command Injection）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%EF%BC%88File-Upload-Vulnerability%EF%BC%89"><span class="toc-text">8. 文件上传漏洞（File Upload Vulnerability）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%EF%BC%88SSRF-Server-Side-Request-Forgery%EF%BC%89"><span class="toc-text">9. 服务器端请求伪造（SSRF, Server-Side Request Forgery）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%88MITM-Man-In-The-Middle%EF%BC%89"><span class="toc-text">10. 中间人攻击（MITM, Man-In-The-Middle）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%EF%BC%88Brute-Force-Attack%EF%BC%89"><span class="toc-text">11. 暴力破解（Brute Force Attack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB%EF%BC%88DoS-DDoS-Denial-of-Service-Distributed-Denial-of-Service%EF%BC%89"><span class="toc-text">12. 拒绝服务攻击（DoS&#x2F;DDoS, Denial of Service&#x2F;Distributed Denial of Service）</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4%EF%BC%9AJavaScript(2%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87)/" title="前端面试突破：JavaScript（2万字长文！！！）"><img src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202409191948011.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端面试突破：JavaScript（2万字长文！！！）"/></a><div class="content"><a class="title" href="/2024/09/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4%EF%BC%9AJavaScript(2%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87)/" title="前端面试突破：JavaScript（2万字长文！！！）">前端面试突破：JavaScript（2万字长文！！！）</a><time datetime="2024-09-19T11:44:55.000Z" title="发表于 2024-09-19 19:44:55">2024-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/31/JavaScript%E7%9A%84FunctionalProgramming/" title="JavaScript函数式编程"><img src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408311908227.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript函数式编程"/></a><div class="content"><a class="title" href="/2024/08/31/JavaScript%E7%9A%84FunctionalProgramming/" title="JavaScript函数式编程">JavaScript函数式编程</a><time datetime="2024-08-31T11:06:53.000Z" title="发表于 2024-08-31 19:06:53">2024-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/30/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="JavaScript之正则表达式"><img src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408302157049.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript之正则表达式"/></a><div class="content"><a class="title" href="/2024/08/30/JavaScript%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="JavaScript之正则表达式">JavaScript之正则表达式</a><time datetime="2024-08-30T13:55:21.000Z" title="发表于 2024-08-30 21:55:21">2024-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/30/JS%E8%A3%85%E9%A5%B0%E5%99%A8Decorator/" title="Decorator——JS装饰器"><img src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408302131697.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Decorator——JS装饰器"/></a><div class="content"><a class="title" href="/2024/08/30/JS%E8%A3%85%E9%A5%B0%E5%99%A8Decorator/" title="Decorator——JS装饰器">Decorator——JS装饰器</a><time datetime="2024-08-30T13:30:00.000Z" title="发表于 2024-08-30 21:30:00">2024-08-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/08/28/JavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/" title="JavaScript的模块化"><img src="https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202408281915497.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaScript的模块化"/></a><div class="content"><a class="title" href="/2024/08/28/JavaScript%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/" title="JavaScript的模块化">JavaScript的模块化</a><time datetime="2024-08-28T11:10:10.000Z" title="发表于 2024-08-28 19:10:10">2024-08-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://d-picture-host-1317679985.cos.ap-nanjing.myqcloud.com/sandox/pic/202409191948011.png')"><div id="footer-wrap"><div class="copyright">&copy;2024 By 灰太羊</div><div class="footer_custom_text"><p> <a style="margin-inline:5px"target="_blank" href="https://hexo.io/"> <img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"> </a> <a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"> <img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"> </a> <a style="margin-inline:5px"target="_blank" href="https://github.com/DRXDRXDRX"> <img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"> </a> <a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"> <img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"> </a> </p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid@10.8.0/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const disqus_config = function () {
    this.page.url = 'https://blog.huitaiyang.top/2024/09/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4%EF%BC%9AJavaScript(2%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87)/'
    this.page.identifier = '/2024/09/19/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%AA%81%E7%A0%B4%EF%BC%9AJavaScript(2%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87)/'
    this.page.title = '前端面试突破：JavaScript（2万字长文！！！）'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Valine' === 'Disqus' || !true) {
    if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>